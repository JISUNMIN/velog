자바스크립트에서 “값이 변한다”는 말, 정말 그럴까요?  
사실 대부분의 경우 **값이 아니라 참조가 바뀌는 것**입니다.

이 글에서는 **원시값과 참조값의 차이**를 통해,  
**복사와 불변성의 동작 원리**를 살펴봅니다.

---

## 1️⃣ 원시값(Primitive) — 값 자체를 저장

원시값은 **값 자체를 복사(copy by value)** 합니다.  
즉, 하나의 변수를 바꿔도 다른 변수에는 영향을 주지 않습니다.

```ts
let a = 10;
let b = a;
b = 20;
console.log(a); // 10
```

원시값은 메모리에 실제 값이 저장되며,  
변수를 변경하더라도 다른 변수에는 영향이 없습니다.

---

## 2️⃣ 원시값은 불변(immutable)

문자열이나 숫자는 **내부를 수정할 수 없습니다.**

```ts
let name = "MIN";
name[0] = "J"; // ❌ 무시됨
console.log(name); // "MIN"
```

문자열 `"MIN"`은 수정되는 대신, 새로운 문자열 `"JIN"`이 만들어져 변수에 다시 저장됩니다.  
원시값은 이런 방식으로 **항상 새로운 값으로 교체**되기 때문에, `readonly` 속성이 필요하지 않습니다.

💡 **참고:**  
ES5(ECMAScript 5) 이후부터 문자열은 배열처럼 `name[0]` 형태로 **인덱스 접근(읽기)** 이 가능해졌습니다.  
하지만 여전히 **수정은 불가능**하며, 새로운 문자열을 만들어야 합니다.

ES5 이전에는 `name.charAt(0)`만 사용할 수 있었습니다.  
`charAt()`은 문자열에서 **특정 인덱스 위치의 문자 하나를 반환**하는 메서드입니다.

```ts
const str = "HELLO";
console.log(str.charAt(1)); // "E"
```

---

## 3️⃣ 참조값(Reference) — 주소를 저장

참조형은 **값 자체가 아니라, 메모리 주소(reference)** 를 저장합니다.  
따라서 여러 변수가 **같은 객체를 함께 참조(공유)** 할 수 있습니다.

```ts
const arr1 = [1, 2, 3];
const arr2 = arr1;
arr2.push(4);
console.log(arr1); // [1, 2, 3, 4]
```

이때 `arr1`과 `arr2`는 동일한 배열 객체를 참조합니다.  
그래서 한쪽에서 내부를 변경하면, 다른 쪽에서도 그 변화가 그대로 반영됩니다.

---

## 4️⃣ 얕은 복사와 깊은 복사

| 구분      | 설명                                          | 예시                      |
| --------- | --------------------------------------------- | ------------------------- |
| 얕은 복사 | 참조만 복사하여 같은 메모리를 공유            | `const arr2 = arr1;`      |
| 깊은 복사 | 새로운 메모리를 생성해 독립적인 데이터를 생성 | `const arr2 = [...arr1];` |

```ts
const arr1 = [1, 2, 3];
const arr2 = [...arr1];
arr2.push(4);
console.log(arr1); // [1, 2, 3]
console.log(arr2); // [1, 2, 3, 4]
```

> 스프레드 연산자(`...`)로 배열을 복사하면 이렇게 동작합니다.

1. **새로운 배열 껍데기(`[]`)를 만든다.**
2. **arr1의 각 요소(1, 2, 3)를 하나씩 복사해서 새 배열에 넣는다.**

```text
arr1 ──▶ [1, 2, 3]
arr2 ──▶ [1, 2, 3]
```

두 배열은 **다른 배열 객체**이지만,
내부 값(1, 2, 3)이 숫자
즉, 원시값(Primitive Type)이기 때문에 **값만 복사되어 서로 영향을 주지 않습니다.**

💡 **중요한 포인트:**

-   `arr2 = arr1`  
    → 같은 배열을 가리켰습니다. 하나를 변경하면 다른 배열도 함께 바뀌었습니다.

-   `arr2 = [...arr1]`  
    → 새로운 배열을 만들고, `arr1`의 값들을 복사해서 넣었습니다. 깊은 복사 처럼 보이지만 **얕은 복사(Shallow Copy)** 이기 때문에 내부에 객체나 배열이 있으면 참조가 공유됩니다.

-   `arr2 = Array.from(arr1)`  
    → 스프레드(`...`)와 동일하게 동작했습니다. 즉, 새로운 배열을 만들되 얕은 복사를 수행했습니다.

> 따라서 스프레드(`...`)나 `Array.from()`은 **깊은 복사(Deep Copy)** 가 아니지만,  
> 배열 안에 **숫자·문자 같은 원시값(Primitive Type)** 만 존재했을 때는  
> 결과적으로 **깊은 복사처럼 보이는 얕은 복사(Shallow Copy)** 가 되었습니다.

### ⚙️ 내부에 객체나 배열이 포함된 경우

```ts
const arr1 = [
    [1, 2],
    [3, 4],
];
const arr2 = [...arr1];

arr2[0].push(99);
console.log(arr1[0]); // [1, 2, 99]  ← 원본도 변경됨
```

겉의 배열은 새로 만들어졌지만,
내부 배열`([1, 2], [3, 4])`은 여전히 **같은 참조를 가리킵니다.**

이럴 때는 `structuredClone()`을 사용해야
내부까지 완전히 복사되는 **진짜 깊은 복사(Deep Copy)** 가 수행됩니다.

```ts
const arr3 = structuredClone(arr1);
```

이 경우, `arr`3를 수정해도 `arr1`에는 **전혀 영향을 주지 않습니다.**

---

## 5️⃣ 함수 매개변수 전달

함수 인자도 복사되지만, 원시값은 ‘값’을, 참조값은 ‘주소’를 복사합니다.

```ts
function changeValue(x: number, arr: number[]) {
    x = 99;
    arr.push(4);
}

let num = 10;
let list = [1, 2, 3];

changeValue(num, list);

console.log(num); // 10
console.log(list); // [1, 2, 3, 4]
```

> 💡 원시값은 독립적으로 복사되지만, 참조값은 같은 객체를 공유합니다.

---

## 6️⃣ 얕은 복사의 한계

얕은 복사는 중첩 객체를 완전히 복사하지 않습니다.

```ts
const user1 = { name: "Min", address: { city: "Seoul" } };
const user2 = { ...user1 };
user2.address.city = "Busan";

console.log(user1.address.city); // "Busan"
```

> 내부 객체는 여전히 같은 참조를 공유하기 때문에, 한쪽을 수정하면 다른 쪽에도 반영됩니다.

💡 **예를 들어**

```ts
user2.name = "Sun";
console.log(user1.name); // "Min"
```

`name`은 **문자열(원시값)** 이라서 복사 시 완전히 새로운 값으로 저장됩니다.
→ 따라서 user2.name을 바꿔도 user1.name에는 영향이 없습니다.

하지만 `address`는 **객체(reference type)** 이기 때문에,
스프레드 연산자로 복사해도 여전히 **같은 객체**를 참조합니다.
→ 따라서 `user2.address.city`를 수정하면 `user1.address.city`도 함께 바뀝니다.

---

## 7️⃣ 불변성의 중요성

### 🔍 불변성이란?

**불변성(immutability)** 이란

> 데이터를 직접 변경하지 않고, **새로운 데이터를 만들어서 교체하는 것**을 의미합니다.

즉, 기존 객체나 배열을 수정하는 대신  
“복사본을 만들어서 일부만 바꾼 새로운 객체”로 대체하는 방식입니다.

```ts
// 가변(mutable)
const user = { name: "Min", age: 20 };
user.age = 30; // 기존 객체를 직접 수정

// 불변(immutable)
const newUser = { ...user, age: 30 }; // 새 객체를 만들어 교체
```

### ⚛️ React에서 불변성의 중요성

React나 Redux에서는 불변성이 매우 중요합니다.  
React는 객체의 **"참조(reference)"** 가 바뀌었는지를 기준으로 상태 변경을 감지합니다.  
즉, 내부 값이 바뀌어도 참조가 그대로면 React는 “안 바뀌었다”고 생각합니다.

```ts
state.user.age = 30;
```

이 코드는 `state` 객체의 **내부 값만 변경**했기 때문에,
React는 여전히 **같은 객체를 참조하고 있다고 판단**하고 **렌더링을 생략**합니다.

```ts
setState({ ...state, user: { ...state.user, age: 30 } });
```

이 코드는

-   `state`를 복사하고,
-   그 안의 `user` 객체도 복사한 뒤,
-   `age`만 수정합니다.

즉, **새로운 참조(reference)** 가 만들어져  
React가 변화를 인식하고 **렌더링이 정상적으로 일어납니다.**

---

### 🔁 Redux에서도 같은 원리

Redux의 `reducer`에서도 항상 **새로운 state 객체를 반환해야** 합니다.

```ts
// ❌ 잘못된 예시 (원본 수정)
state.user.age = 30;
return state;

// ✅ 올바른 예시 (새 객체 반환)
return {
    ...state,
    user: { ...state.user, age: 30 },
};
```

> 불변성을 지키면 React의 **상태 변화 감지(diff)** 와 **렌더링 최적화**가 가능해집니다.

---

## 8️⃣ 참조형과 원시형의 === 비교 차이

```ts
const a = [1, 2];
const b = [1, 2];
console.log(a === b); // false

const c = a;
console.log(a === c); // true
```

> 객체나 배열은 **내용이 아니라 참조 주소**로 비교됩니다.

### 💡 왜 false일까?

`a`와 `b`는 겉보기에는 `[1, 2]`로 같아 보이지만,  
각각 **다른 메모리 주소**에 저장된 **서로 다른 객체**입니다.  
따라서 `===` 비교는 `false`를 반환합니다.

반면,  
`const c = a;` 처럼 **같은 객체를 참조하는 변수끼리**는  
**같은 주소를 가리키므로 `true`** 가 됩니다.

### 🔍 원시값 비교와의 차이

```ts
const x = 10;
const y = 10;
console.log(x === y); // true ✅
```

숫자, 문자열, 불리언 등 **원시값(primitive type)** 은  
**값 자체를 비교하기 때문에**,  
동일한 값이면 항상 `===` 비교 결과가 `true`입니다.

### 🔍 === 와 == 의 차이

| 구분          | `===` (엄격 비교, strict equality) | `==` (느슨한 비교, loose equality)           |
| ------------- | ---------------------------------- | -------------------------------------------- |
| **형 변환**   | ❌ 안 함                           | ✅ 함 (자동으로 타입을 맞춤)                 |
| **비교 기준** | 타입과 값이 모두 같아야 `true`     | 타입이 다르면 내부적으로 형 변환 후 비교     |
| **권장 여부** | ✅ 항상 권장                       | ⚠️ 예외적인 경우만 사용 (`value == null` 등) |

```ts
console.log("10" === 10); // false ❌ (타입 다름)
console.log("10" == 10); // true ⚠️ (문자열 → 숫자 자동 변환)
console.log(true == 1); // true ⚠️
```

즉, `===`는 **형 변환 없이 “있는 그대로” 비교**하고,
`==`는 **타입을 강제로 변환해서 느슨하게 비교**합니다.

---

## 9️⃣ Object.freeze()

`Object.freeze()`는 객체를 동결(freeze)하여 속성 변경을 막습니다.

```ts
const obj = Object.freeze({ a: 1 });
obj.a = 2; // 무시됨
console.log(obj.a); // 1
```

> 단, 얕은 수준의 불변성만 제공하므로 중첩 객체는 여전히 변경될 수 있습니다.

### 💡 얕은 수준(shallow)만 동결된다는 뜻

`Object.freeze()`는 객체의 **1단계(바로 안에 있는 속성)** 까지만 동결합니다.  
즉, **내부에 중첩된 객체는 그대로 수정이 가능합니다.**

```ts
const user = Object.freeze({
    name: "Min",
    address: { city: "Seoul" },
});

user.name = "Sun"; // 무시됨 (최상위 속성은 동결)
user.address.city = "Busan"; // 변경됨 (내부 객체는 여전히 수정 가능)
console.log(user.address.city); // "Busan"
```

이유는 `Object.freeze()`가 **외부 객체의 속성값만 고정하기 때문입니다.**  
즉, `user.address`라는 속성(주소칸)은 바꿀 수 없지만,  
그 속성이 가리키는 내부 객체(`address`)의 내용(`city`)은 여전히 수정할 수 있습니다.

---

## 🔟 `as const` — 타입 수준의 불변성 

`as const`는 **TypeScript에서 값의 불변성을 타입 수준으로 보장**할 때 사용합니다.  
원시값은 타입만 고정되고, 참조값에는 `readonly` 속성이 추가됩니다.

```ts
const name = "MIN" as const; // 타입: "MIN"
const arr = ["a", "b"] as const; // 타입: readonly ["a", "b"]
```

> 자바스크립트 런타임에서 동작이 바뀌는 것은 아니지만,  
> TypeScript는 `as const`를 통해 **개발 단계에서 불변성을 강제**할 수 있습니다.

```ts
const name = "MIN" as const; // 타입: "MIN" (리터럴로 고정)
const arr = ["a", "b"] as const; // 타입: readonly ["a", "b"]
arr[0] = "c"; // ❌ 오류 — 읽기 전용 배열
```
`"MIN"`은 더 이상 일반 문자열이 아니라` "MIN" 그 자체`로 인식됩니다.
배열은 **읽기 전용(readonly)** 이 되어, 컴파일 시점에 변경 시 에러가 발생합니다

---

## 💬 마무리

자바스크립트에서 **“값이 변한다”**는 말은,  
사실 **“변수가 새로운 값을 가리키게 된다”**는 뜻입니다.  

> 원시값은 **복사되어 새로 만들어지고**,  
> 참조값은 **하나의 데이터를 함께 공유**합니다.

즉, 원시값은 항상 **새로운 데이터**,  
참조값은 **공유된 데이터**로 동작합니다.  

이 차이를 이해하면  
`불변성(immutability)`과  
`Object.freeze()`, `as const`, `readonly` 같은 기능의 의미를  
더 명확히 이해할 수 있습니다.
