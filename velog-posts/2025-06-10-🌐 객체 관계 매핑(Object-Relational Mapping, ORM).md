![](https://velog.velcdn.com/images/sunmins/post/48a3eaf1-f950-43bb-a397-f23635ca5b86/image.webp)
객체 관계 매핑(Object-Relational Mapping)의 줄임말로, 객체 지향 프로그래밍 언어의 객체와 관계형 데이터베이스를 서로 연결하고 매핑하는 기술
즉, 객체를 사용하여 데이터베이스 데이터를 다룰 수 있도록 돕는 프레임 워크나 도구 

✅ **주요 기능**

### 객체와 테이블 간 매핑
- 클래스 ↔ 테이블  
- 객체의 필드 ↔ 테이블의 컬럼  
- 객체 간 관계 ↔ 외래 키 등으로 매핑

### SQL 쿼리 자동 생성
- 기본적인 `INSERT`, `SELECT`, `UPDATE`, `DELETE` 쿼리를 자동으로 생성  
- 복잡한 쿼리도 메서드 체이닝이나 DSL 형식으로 표현 가능

### 데이터베이스 접근 간소화
- `EntityManager` 또는 `Repository`를 통해 객체 단위로 데이터베이스 CRUD 작업 수행  
- 트랜잭션 관리 및 연결 풀 등도 함께 제공

---

🌟 **장점**

### 생산성 향상
- 반복적인 SQL 작성 없이 비즈니스 로직에 집중 가능

### 가독성 및 유지보수 용이
- 도메인 객체 중심 코드로 코드의 일관성과 명확성 증가

### DB 벤더 독립성
- 특정 DBMS에 종속되지 않고 다양한 DB에서도 동일 코드 재사용 가능

### 트랜잭션 및 연결 관리 내장
- 직접 connection을 열고 닫는 코드를 작성할 필요 없음

---

⚠️ **단점**

### 성능 이슈 가능성
- 복잡한 쿼리는 자동 생성된 SQL이 비효율적일 수 있음 (`N+1 문제` 등)

### 초기 학습 곡선
- 매핑 방식, 설정, 생명주기 등 개념 학습이 필요

### 복잡한 쿼리 작성의 한계
- 복잡한 `join`, `subquery` 등은 직접 native SQL을 써야 할 때도 있음

### 디버깅 어려움
- 내부적으로 자동 생성된 SQL을 추적하거나 최적화하기 어려운 경우 존재




## ✅ 가장 큰 장점: 생산성 향상

ORM을 사용하면 SQL을 직접 작성하지 않고도 객체 지향 방식으로 데이터베이스 작업이 가능해집니다.  
이는 반복적인 쿼리 작성 부담을 줄이고, **비즈니스 로직에 집중할 수 있는 개발 환경**을 제공합니다.

- 객체를 통해 DB 접근 가능
- 코드의 일관성과 유지보수성 향상
- 생산성 높은 도메인 중심 개발 가능

---

## ⚠️ 가장 큰 단점: 성능 이슈 가능성

ORM이 자동으로 생성하는 SQL이 항상 최적화된 것은 아니며,  
특히 **N+1 문제**, **불필요한 쿼리 발생**, **복잡한 관계에서의 성능 저하** 등 이슈가 생길 수 있습니다.

- 대규모 데이터 또는 복잡한 쿼리에서 비효율 발생 가능
- 튜닝이 어렵고 예측하기 힘든 SQL 생성
- 결국 native SQL을 직접 작성해야 할 경우도 존재

---

# N+1 문제 해결 방법

## 1. Join Fetch (즉시 로딩 명시)
- ORM 설정에서 기본 로딩 전략을 **지연로딩(Lazy)에서 즉시로딩(Eager)**으로 변경
- 연관 데이터를 한 번의 쿼리로 JOIN해서 함께 조회
- ORM에서 `join fetch`, `leftJoinAndSelect` 등 기능 사용
- 예시 (TypeORM):
  ```typescript
  const posts = await postRepository
    .createQueryBuilder("post")
    .leftJoinAndSelect("post.author", "author")
    .getMany();

```sql
SQL 결과:
SELECT p.*, a.* FROM posts p
LEFT JOIN authors a ON p.author_id = a.id;
```
# 복잡한 관계에서의 성능 저하 문제 해결 방법

## 1. Native Query 사용

- ORM이 자동 생성하는 쿼리가 비효율적일 때 직접 SQL을 작성
- 복잡한 조인, 서브쿼리, 집계 함수 등 최적화된 쿼리를 자유롭게 작성 가능
- Prisma 기준: `$queryRaw` 사용
- 장점
  - 성능 최적화 가능
  - ORM 추상화에 제한받지 않음
- 단점
  - DBMS 종속적일 수 있음
  - ORM의 타입 안전성, 자동 매핑, 보안 기능 상실 가능
  - 유지보수 어려울 수 있음
---




| 용어           | 의미                       | 장점           | 단점              |
| ------------ | ------------------------ | ------------ | --------------- |
| 지연 로딩        | 실제 필요할 때 데이터를 가져옴        | 초기 쿼리 가벼움    | N+1 문제 발생 가능    |
| 즉시 로딩        | 처음부터 연관 데이터 모두 가져옴       | 추가 쿼리 없음     | 불필요한 데이터 로딩 가능  |
| Join Fetch   | 즉시 로딩 중 하나로 조인을 이용해 한번에 가져오기 | N+1 문제 예방    | 복잡한 쿼리 시 어려움    |
| N+1 문제       | 연관 데이터 반복 조회로 쿼리 폭증      | -            | 성능 저하           |
| Native Query | 직접 SQL 작성, ORM의 추상화 없이 직접 SQL문법으로 작성한 쿼리               | 복잡한 쿼리 작성 가능 | ORM의 추상화 혜택 미적용 |



