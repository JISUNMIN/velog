<p>프론트엔드 개발을 하다 보면<br />번들러, 트랜스파일러, 빌드 도구처럼<br />비슷한 용어들이 한꺼번에 등장해 헷갈릴 때가 많습니다.<br />그래서 이번 기회에 이러한 개념들을 하나씩 정리해보려고 하며,<br />이번 글은 그중에서도 가장 기본이 되는 <strong>번들러(Bundle)</strong>부터 살펴보겠습니다.</p>
<hr />
<p><strong>번들러(Bundle)는<br />“여러 파일을 하나로 묶어 브라우저가 더 빠르고 효율적으로 실행할 수 있게 해주는 도구”입니다.</strong></p>
<p>프로젝트는 컴포넌트, 유틸 함수, 라우터, 상태 관리 코드 등
수많은 <strong>JS 파일(모듈)</strong>로 구성되기 때문에
그대로 브라우저에 로드하면 속도 저하와 관리 문제가 생깁니다.
번들러는 이 모듈들을 분석해 하나 또는 소수의 번들 파일로 만들어줍니다.</p>
<blockquote>
<p>“여러 조각난 JS 파일들을 하나로 포장해
브라우저가 부담 없이 실행할 수 있게 도와주는 도구”</p>
</blockquote>
<p>라고 이해할 수 있습니다.</p>
<p><strong>번들러와 빌드 도구는 실제 개발 환경에서 함께 사용되기 때문에
둘의 역할이 모호하게 느껴질 때가 많습니다.</strong>
특히 <strong>CSS·이미지·폰트 같은 리소스 처리는 번들러가 아닌 빌드 도구의 역할</strong>입니다.
이러한 리소스는 빌드 도구가 JS 모듈처럼 변환해 주어야만
번들러가 번들 과정에서 함께 처리할 수 있습니다.</p>
<p>이 글에서는 개념을 명확히 하기 위해
<strong>번들러가 실제로 맡는 기능(JS 모듈 번들링)</strong>에만 초점을 맞추고 정리했습니다.</p>
<hr />
<h2 id="💡-왜-번들러가-필요할까">💡 왜 번들러가 필요할까?</h2>
<p>옛날 웹 개발은 이렇게 단순했습니다:</p>
<pre><code class="language-html">&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>단 하나의 JS 파일.</p>
<p>하지만 현대 FE 개발에서는:</p>
<ul>
<li>컴포넌트 파일 (Hello.jsx, Button.jsx)</li>
<li>라우터, API 파일</li>
<li>상태 관리, 훅(hook) 모듈</li>
<li>유틸 함수 모듈</li>
<li>라이브러리 수십 개</li>
</ul>
<p>이 모든 파일이 각각 개별 모듈입니다.</p>
<p>예:</p>
<pre><code>src/
 ├─ components/
 │   ├─ Button.jsx
 │   ├─ Input.jsx
 ├─ pages/
 │   ├─ Home.jsx
 │   ├─ Login.jsx
 ├─ utils/
 │   └─ api.js
 └─ main.jsx</code></pre><p>브라우저가 이것들을 그대로 로드한다면?</p>
<ul>
<li>HTTP 요청 수 급증 → 속도 저하  </li>
<li>파일 간 의존성 충돌  </li>
<li>모듈 관리 어려움  </li>
<li>코드가 그대로 노출됨(보안 취약)  </li>
<li>실행하기 전에 모든 파일 다운로드 필요 → 느린 초기 로딩</li>
</ul>
<p>➡ 그래서 필요한 것이 <strong>번들러(Bundle)</strong> 입니다.</p>
<h3 id="1-여러-모듈을-하나의-번들로-묶기">1) 여러 모듈을 하나의 번들로 묶기</h3>
<p>→ 브라우저 요청 수 감소 → 초기 로딩 개선</p>
<p>프론트엔드 프로젝트는 수십~수백 개의 JS 모듈을 사용합니다.
이 파일들을 브라우저가 각각 요청하면 속도가 매우 느려지기 때문에
번들러는 <strong>모듈 의존성 그래프를 분석</strong>하여</p>
<ul>
<li>하나의 큰 JS 파일로 묶거나</li>
<li>페이지/라우트 단위로 여러 개의 번들 파일을 만들어</li>
</ul>
<p><strong>요청 수를 줄이고 로딩 전략을 최적화</strong>합니다.</p>
<h3 id="2-tree-shaking">2) Tree-shaking</h3>
<p>→ 사용하지 않는 코드 자동 제거</p>
<p>모듈 안에 여러 함수가 있어도 실제로 쓰지 않는 함수는<br />최종 번들에서 제거합니다.</p>
<p>예:</p>
<pre><code class="language-js">export function add() {}
export function remove() {} // 사용 안 함</code></pre>
<p>번들 결과물에는 <code>add()</code>만 포함됩니다.
→ 불필요한 코드 제거 → 파일 크기 감소.</p>
<h3 id="3-minify--난독화">3) minify / 난독화</h3>
<p>→ 파일 크기 감소<br />→ 해커가 코드를 읽기 어렵도록 보호</p>
<p>예:</p>
<ul>
<li><p>원본</p>
<pre><code class="language-js">function add(a, b) {
return a + b;
}
console.log(add(1, 2));</code></pre>
</li>
<li><p>압축 + 난독화 후</p>
<pre><code class="language-js">function a(b,c){return b+c}console.log(a(1,2));</code></pre>
</li>
<li><p>공백/줄바꿈 제거</p>
</li>
<li><p>변수 이름을 짧게 변경</p>
</li>
<li><p>구조 단순화</p>
</li>
</ul>
<p>→ 파일 크기 감소
→ 코드를 해석하기 어려워져 어느 정도 보안 효과도 있음</p>
<hr />
<h2 id="⚠️-번들링은-빌드라는-큰-과정의-일부입니다">⚠️ 번들링은 “빌드”라는 큰 과정의 일부입니다.</h2>
<p>프론트엔드에서 <strong>빌드(Build)</strong> 는 프로젝트를 실제 배포 가능한 형태로 만드는 전체 과정이고,<br /><strong>번들링(Bundle)</strong> 은 그 안에서 여러 파일(JS/CSS/이미지 등)을 묶고 최적화하는 단계입니다.</p>
<pre><code class="language-text">빌드(build)
├─ 번들링(bundle)         → 여러 JS 모듈을 하나/소수의 번들로 묶기
├─ 트랜스파일(transpile) → TS/JSX → JS 변환
├─ 최적화(optimize) → minify, tree-shaking
├─ 리소스 처리 → CSS/이미지 해시 추가 및 복사
└─ dist 결과물 생성 → 배포용 폴더 만들기</code></pre>
<ul>
<li><strong>Webpack</strong> → 번들링 + 빌드 시스템을 동시에 제공하는 올인원 도구  </li>
<li><strong>Rollup, esbuild</strong> → 번들링에 집중된 도구  </li>
<li><strong>Vite</strong> → 개발은 esbuild, 빌드는 Rollup을 사용해 전체 빌드 과정을 구성</li>
</ul>
<p>즉, <strong>번들러는 빌드 과정에 포함된 하나의 기능</strong>이며<br />도구마다 “빌드+번들링”을 모두 하기도 하고,<br />“번들링” 기능만 제공하기도 합니다.</p>
<hr />
<h1 id="🔍-번들링-전후-비교">🔍 번들링 전/후 비교</h1>
<h3 id="📁-번들링-전">📁 번들링 전</h3>
<pre><code>Button.jsx
Input.jsx
Home.jsx
Login.jsx
styles/main.css
utils/api.js</code></pre><h3 id="📁-번들링-후">📁 번들링 후</h3>
<pre><code>dist/
 ├─ index.html
 └─ assets/
     └─ main-98f2d.js</code></pre><p>브라우저는 <strong>단 하나의 JS 번들 파일만</strong> 다운로드하면
그 안에 포함된 모든 모듈 코드를 한 번에 사용할 수 있습니다.</p>
<hr />
<h2 id="esm-시대에도-번들러가-필요한-이유">ESM 시대에도 번들러가 필요한 이유</h2>
<p>ESM(ES Modules)이 도입되면서 브라우저는<br /><strong>JS 파일의 import/export 문법을 직접 이해</strong>할 수 있게 되었습니다.<br />하지만 그렇다고 번들러가 필요 없어지는 것은 아닙니다.</p>
<pre><code class="language-js">// 이런 코드들을 브라우저가 직접 해석할 수 있음
import { add } from &quot;./math.js&quot;;
import Button from &quot;./Button.js&quot;;</code></pre>
<hr />
<h3 id="1-요청-수-문제는-그대로-남아-있음">1) 요청 수 문제는 그대로 남아 있음</h3>
<p>대규모 프로젝트에서 import가 수십~수백 개가 되면,
이를 ESM로 그대로 요청할 경우 브라우저는 각 모듈을 개별 파일로 받아야 합니다.</p>
<p>→ 네트워크 요청 수가 많아지고
→ 초기 로딩 속도가 느려질 수 있습니다.</p>
<p>번들러는 이 많은 모듈들을 소수의 번들 파일로 묶어
요청 수를 줄여줍니다.</p>
<h3 id="2-번들러-레벨의-최적화">2) 번들러 레벨의 최적화</h3>
<p>번들러는 모듈 그래프 전체를 알고 있기 때문에:</p>
<ul>
<li>사용하지 않는 모듈/코드를 제거(Tree-shaking)</li>
<li>공통 코드 분리(코드 스플리팅)</li>
<li>동일 모듈의 중복 로드 방지</li>
<li>Minify/난독화 적용</li>
</ul>
<p>같은 최적화를 한 번에 적용할 수 있습니다.</p>
<hr />
<h2 id="🛠-대표-번들러">🛠 대표 번들러</h2>
<h3 id="✔️--webpack--전통의-강자-가장-유연한-번들러">✔️  Webpack — 전통의 강자, 가장 유연한 번들러</h3>
<pre><code>Webpack = 번들러 + 빌드 시스템</code></pre><ul>
<li>React, Vue, Angular 등 초기 FE 프레임워크의 기본 번들러로 사용되며
수년간 업계 표준처럼 자리 잡음</li>
<li>Create React App(CRA)의 기반이기도 해서
“FE = Webpack” 구조가 오랫동안 유지됨</li>
</ul>
<h4 id="장점">장점</h4>
<ul>
<li>플러그인/로더 생태계가 가장 크고 강력함
(CSS/SASS, SVG, 이미지, 폰트 등 어떤 파일도 처리 가능)</li>
<li>단순 번들러가 아니라
HMR 개발 서버 + 프로덕션 빌드 엔진까지 모두 포함한 올인원 구조</li>
</ul>
<h4 id="단점">단점</h4>
<ul>
<li>설정이 복잡하고 진입 장벽이 높음</li>
<li>대규모 프로젝트에서 빌드 속도가 느릴 수 있음</li>
<li>Vite·esbuild 같은 신형 도구가 등장하면서 신규 프로젝트에서는 감소 추세</li>
</ul>
<hr />
<h3 id="✔️--rollup--es-모듈-기반-라이브러리-빌드-특화">✔️  Rollup — ES 모듈 기반, 라이브러리 빌드 특화</h3>
<p><strong>최종 빌드(프로덕션)를 담당하는 번들러</strong>
<strong>Vite의 빌드 단계에서도 Rollup이 사용됨</strong></p>
<h4 id="장점-1">장점</h4>
<ul>
<li>번들 크기가 매우 작고 최적화 품질이 뛰어남</li>
<li>Tree-shaking 정확도 최고 수준</li>
<li>라이브러리(NPM 패키지) 빌드에 특히 강함
(React 라이브러리 등 많은 패키지가 Rollup 기반)</li>
</ul>
<h4 id="단점-1">단점</h4>
<ul>
<li>*<em>개발 경험(HMR, 빠른 갱신 등)은 부족함 *</em></li>
<li>SPA 개발을 단독으로 하기엔 설정/속도 측면에서 불편</li>
</ul>
<hr />
<h3 id="✔️--esbuild--미친-속도를-가진-초고속-번들러">✔️  esbuild — 미친 속도를 가진 초고속 번들러</h3>
<p>esbuild = 초고속 번들러 + 트랜스파일러
<strong>Vite의 개발(dev) 모드에서 사용됨</strong></p>
<h4 id="장점-2">장점</h4>
<ul>
<li>Go로 만들어져서 번들링/컴파일 속도 매우 빠름 </li>
<li>TypeScript/JSX 변환 속도 업계 최고</li>
<li>개발 중 HMR 반응 속도가 매우 빠름 
→ Vite 개발 경험이 좋은 핵심 이유</li>
<li>설치/사용이 간단</li>
</ul>
<h4 id="단점-2">단점</h4>
<ul>
<li>프로덕션 최적화는 Rollup보다 정교하지 않음</li>
<li>큰 프로젝트에서 Code-splitting 전략 등이 Rollup만큼 뛰어나지 않음</li>
</ul>
<h4 id="👉-그래서-vite는-개발은-esbuild-빌드는-rollup로-조합한-구조를-선택함">👉 그래서** Vite는 개발은 esbuild, 빌드는 Rollup로 조합한 구조**를 선택함.</h4>
<hr />
<h3 id="✔️-parcel--zero-config-철학을-가진-자동화-빌드-시스템">✔️ Parcel — Zero-config 철학을 가진 자동화 빌드 시스템</h3>
<p>Parcel = 번들러 + 빌드 시스템(트랜스파일링 자동 포함)</p>
<p>설정 없이도 거의 모든 종류의 파일(TS, JSX, 이미지, CSS 등)을 자동으로 처리하는<br /><strong>‘무설정(Zero-config)’ 번들러</strong>로 유명.  </p>
<h4 id="장점-3">장점</h4>
<ul>
<li><strong>Zero-config:</strong> TS/JSX/이미지/CSS 등 대부분 자동 처리</li>
<li><strong>자동 최적화:</strong> 코드 스플리팅, 캐싱, 압축 등 빌드 과정 전체 자동화</li>
<li>빠른 HMR &amp; 빌드 속도</li>
<li>Webpack 대비 훨씬 간단한 구조로 DX(개발 경험) 우수</li>
<li>내부적으로 Babel/SWC/TS 컴파일러 사용해 자동 트랜스파일링</li>
</ul>
<h4 id="단점-3">단점</h4>
<ul>
<li>Webpack만큼 세밀하게 커스터마이즈하기 어려움</li>
<li>생태계(플러그인)가 상대적으로 적음</li>
<li>특정 고급 빌드 요구사항에서는 Rollup/Webpack보다 융통성이 떨어짐</li>
</ul>
<hr />
<h2 id="✅-비교">✅ 비교</h2>
<table>
<thead>
<tr>
<th>도구</th>
<th>역할</th>
<th>특징</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Webpack</strong></td>
<td>번들러 + 빌드 시스템</td>
<td>가장 유연, 설정 복잡</td>
</tr>
<tr>
<td><strong>Rollup</strong></td>
<td>번들러</td>
<td>라이브러리용, 최적화 우수</td>
</tr>
<tr>
<td><strong>esbuild</strong></td>
<td>번들러 + 트랜스파일러</td>
<td>속도 최강, dev 환경에 최적</td>
</tr>
<tr>
<td><strong>Parcel</strong></td>
<td>번들러 + 빌드 시스템(트랜스파일링 포함)</td>
<td>Zero-config, 자동 최적화</td>
</tr>
</tbody></table>
<hr />
<h2 id="📌-한-줄-요약">📌 한 줄 요약</h2>
<blockquote>
<p><strong>번들러(Bundle)는 여러 JS 모듈을 중심으로,
하나 또는 소수의 번들 파일로 묶고,
tree-shaking·minify 같은 최적화를 적용해
브라우저가 더 빠르고 효율적으로 코드를 실행할 수 있게 해주는 도구이다.</strong></p>
</blockquote>