**`map()`**은 배열에서 자주 사용되는 함수지만, **객체에서는 바로 사용할 수 없습니다.** 하지만 **`Object.entries()`를 활용**하면 **객체를 배열처럼 변환**하여 **`map()`을 적용할 수 있습니다.**

---

## 🔄 비교

| 구분               | 함수 이름              | 반환값 종류                      | 동작 방식                               | 활용 예시                                     |
|--------------------|------------------------|----------------------------------|----------------------------------------|----------------------------------------------|
| **객체 → 배열 변환** | `Object.entries()`      | **2차원 배열 (`[key, value][]`)** | 객체의 키-값 쌍을 배열로 변환              | 객체를 순회하거나 필터링할 때                     |
| 배열 가공           | `.map()`               | 새로운 배열                      | 각 `[key, value]` 쌍을 변형                 | 객체 → 다른 형태의 배열, 객체 재구성 등            |
| **객체=> 배열 가공 후 반복 **     | `Object.entries().map()`| 새로운 배열                      | 객체를 배열로 바꾼 뒤, 각 쌍을 가공           | 객체를 순회하면서 key, value 기반 새 배열 만들기     |

> 참고 
- Object.entries({}); // []
- [].map(x => x * 2); // []
- Object.entries({}).map(([k, v]) => v); // []


---


## 📌 기본 사용법

```js
const user = {
  name: 'Alice',
  age: 30,
  job: 'Developer'
};

const entries = Object.entries(user);
console.log(entries);
// [['name', 'Alice'], ['age', 30], ['job', 'Developer']]
이제 entries는 2차원 배열이므로 map()을 사용할 수 있습니다.
```


### ✨ 예시 1: key-value 쌍을 문자열로 변환
```js
const summary = Object.entries(user).map(([key, value]) => {
  return `${key}: ${value}`;
});

console.log(summary);
// ['name: Alice', 'age: 30', 'job: Developer']
```

### ✨ 예시 2: value만 추출하여 대문자로 변환 (value가 문자열일 때)
```js
const upperValues = Object.entries(user)
  .filter(([, value]) => typeof value === 'string')
  .map(([, value]) => value.toUpperCase());

console.log(upperValues);
// ['ALICE', 'DEVELOPER']
```

>💡 Object.values()도 사용 가능
```js
const upperValues = Object.values(user)
  .filter(value => typeof value === 'string')
  .map(value => value.toUpperCase());
```
❓차이점
Object.entries()는 [key, value] 쌍을 다루기 때문에, 키가 필요한 경우에 유용합니다.
Object.values()는 값만 필요할 때 간단하게 쓸 수 있습니다.



### ✨ 예시 3: Object.fromEntries()로 다시 객체로 변환
```js
const modified = Object.fromEntries(
  Object.entries(user).map(([key, value]) => [key, String(value)])
);

console.log(modified);
// 숫자 30이 문자열 '30'으로 변환됨
// { name: 'Alice', age: '30', job: 'Developer' }
```

#### ✅ 각각의 결과
```js
// 1. Object.entries(user) → 객체를 [key, value] 배열로 변환
[ ['name', '홍길동'], ['age', 30], ['job', '개발자'] ]

// 2. .map(([key, value]) => [key, String(value)]) → 값 변형 (숫자 30을 문자열 '30'으로 변환)
[ ['name', '홍길동'], ['age', '30'], ['job', '개발자'] ]

// 3. Object.fromEntries(...) → 배열을 다시 객체 형태로 변환
{
  name: '홍길동',
  age: '30',        // 숫자 30이 문자열 '30'으로 변환됨
  job: '개발자'
}
```
이 과정을 통해, 객체의 값을 쉽게 변형하고 새로운 객체를 만들 수 있습니다.


>❓왜 이렇게 쓰나요
**객체는 배열 메서드를 직접 쓸 수 없기 때문입니다.**
map(), filter(), reduce() 같은 유용한 배열 함수들은 객체에 없기 떄문에 객체를 [key, value] 쌍의 배열로 바꾸면, 배열 메서드를 자유롭게 쓸 수 있습니다.





## ✅ 요약 정리

- `Object.entries()`를 사용하면 객체를 배열 형태로 변환하여 배열 메서드를 활용할 수 있습니다.  
- `map()`과 결합해 각 키-값 쌍을 쉽게 가공할 수 있습니다.  
- 가공한 배열을 `Object.fromEntries()`로 다시 객체로 변환할 수 있습니다.  
⚠️
  - 객체 속성의 순서는 표준적으로 보장되지 않아, 순서에 의존하는 로직에는 주의가 필요합니다. 
  - 중첩된 객체는 한 번에 변환할 수 없으며, 별도의 처리 과정이 필요해 다루기 복잡합니다.