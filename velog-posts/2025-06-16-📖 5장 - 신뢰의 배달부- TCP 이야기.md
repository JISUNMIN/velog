## 📦 TCP란?

IP만으로는 데이터를 정확히 전달할 수 없습니다.  
IP는 택배로 비유하자면, **내용물이 빠졌는지**, **내가 주문한 순서대로 왔는지** 등은 신경 쓰지 않고, **단순히 목적지까지 배송만(안내만)** 책임집니다.  
그래서 **신뢰성 있는 데이터 통신**을 위한 프로토콜이 필요하고, 그것이 바로 **TCP (Transmission Control Protocol)**입니다.

> **신뢰성이란?**  
> 언제 어디서든 데이터를 **온전히 전달받을 수 있다는 보장**을 의미합니다.

---

## ❓ TCP는 왜 생겨났을까?

인터넷은 데이터를 **패킷 교환 방식**으로 전달합니다.  
이 방식은 특정 회선에 문제가 생겨도 **패킷이 우회하여 도착할 수 있다는 장점**이 있지만, **중간에 일부 패킷이 사라질 수 있다는 문제**도 존재합니다.  

TCP는 이러한 오류를 감지하고 해결하여, **데이터를 온전히 전달할 수 있도록 돕는 프로토콜**입니다.

- TCP는 **패킷마다 번호(시퀀스 번호)**를 부여하여 어떤 패킷이 사라졌는지 파악합니다.
- 데이터를 주고받을 때 **확인 절차(ACK)**를 추가하여, 데이터가 제대로 도착했는지 검증합니다.

---

## TCP의 헤더와 플래그

모든 프로토콜은 데이터 앞에 **헤더(header)**라는 정보를 추가하여 전송합니다.  
헤더에는 해당 데이터에 대한 정보가 담겨 있으며, **출발지/도착지 등의 공통 정보 외에도 프로토콜에 따라 내용이 달라집니다.**

TCP는 **신뢰성을 책임지는 프로토콜**이기 때문에, 다른 프로토콜보다 헤더가 크며 더 많은 정보를 포함하고 있습니다.

### TCP 헤더에 포함된 주요 정보

1. **시퀀스 번호(Sequence Number)**: 패킷이 순서대로 도착했는지 확인
2. **윈도 크기(Window Size)**: 수신자가 처리할 수 있는 데이터의 양
3. **플래그(Flag)**: 패킷의 상태를 알려주는 정보

### 주요 플래그 종류

- **ACK (Acknowledgement)**: 데이터를 잘 받았음을 알림
- **SYN (Synchronize)**: 연결 설정을 요청
- **FIN (Finish)**: 연결 종료 요청

---

##  🤝 핸드셰이크(Handshake)

예를 들어 체육 시간에 배구공을 주고받는다고 가정해 봅시다.  
서로 준비되지 않은 상태에서 공을 던지면 **다칠 수 있기 때문에**, 준비가 되었는지 **확인하는 과정이 필요**합니다.  
TCP도 마찬가지로, 클라이언트와 서버가 서로 **연결된 상태를 유지하며 데이터 전달**을 수행합니다.  
그래서 TCP는 **연결형 프로토콜(Connection-oriented Protocol)**이라 불립니다.

### 연결 시작 - 3-way Handshake

1. 클라이언트 → 서버 : SYN
2. 서버 → 클라이언트 : SYN + ACK
3. 클라이언트 → 서버 : ACK

### 연결 종료 - 4-way Handshake

1. 클라이언트 → 서버 : FIN
2. 서버 → 클라이언트 : ACK  
3. 서버 → 클라이언트 : FIN  
4. 클라이언트 → 서버 : ACK

---

## 💧 흐름 제어 (Flow Control)

TCP가 정상적으로 데이터를 전달받지 못하는 이유 중 하나는 **전송자와 수신자 간의 속도 차이**입니다.

> 예시:  
> 공을 던지는 게임에서, 받는 사람보다 던지는 사람이 너무 빠르면 공을 놓치게 됩니다.

TCP는 **수신자의 속도에 맞춰 전송 속도를 조절**하는 기능을 제공합니다.

### 흐름 제어 방식

1. **정지-대기 방식 (Stop-and-Wait)**  
   - 매번 패킷을 전송한 뒤, **응답을 받을 때까지 기다림**  
   - 단점: **속도가 매우 느리고 비효율적**이기 때문에 오늘날 거의 사용되지 않음

2. **슬라이딩 윈도(Sliding Window)**  
   - **수신자가 감당할 수 있는 양**만큼만 데이터를 전송  
   - **효율적이고 현대 TCP의 핵심 방식**

---

## 🌐 혼잡 제어 (Congestion Control)

네트워크에 **너무 많은 데이터가 몰리면**, **처리 속도가 떨어지는 문제**가 발생합니다.  
그러나 전송자와 수신자는 네트워크 상태를 직접 알 수 없기 때문에:

- 수신자는 못 받은 데이터에 대해 **재전송 요청**을 보냅니다.
- 전송자는 **데이터가 유실되었다고 판단하고 재전송**을 시도합니다.

> 결과적으로 네트워크에 **더 많은 데이터가 쌓이게 되어 혼잡이 심화**됩니다.  
> 이처럼 **네트워크 내 패킷 수가 과도하게 증가**하는 현상을 **혼잡(Congestion)**이라 하며, 이를 방지하기 위한 기능이 **혼잡 제어**입니다.

### 혼잡 제어 방식

1. **Additive Increase / Multiplicative Decrease (AIMD)**  
   - 전송 속도를 1씩 증가하다가 혼잡 발생 시 **절반으로 감속**

2. **느린 시작 (Slow Start)**  
   - 처음에는 윈도 크기를 1로 시작하여, **2배씩 증가**  
   - 혼잡이 발생하면 **윈도 크기를 1로 초기화**

---

## 📡 UDP란?

UDP(User Datagram Protocol)는 **연결을 확인하지 않고** 데이터를 일방적으로 전송하는 프로토콜입니다.  
즉, 상대방과 잘 연결되었는지 확인하는 절차가 없고, **비연결형 프로토콜(Connectionless Protocol)**입니다.  
또한, 들어오는 데이터의 순서도 중요하게 여기지 않으며, 일부 데이터가 유실되어도 크게 문제 되지 않는 경우에 적합합니다.  

> 예시)
> 체육 시간에 던지는 학생이 엄청 빠르게 공을 던져서 받는 친구는 공을 몇개 떨어뜨림

예를 들어, 실시간 스트리밍, 음성 통화, 온라인 게임 등에서는 조금의 데이터 유실보다 **지연 없이 빠르게 전달하는 것**이 더 중요하기 때문에 UDP를 주로 사용합니다.

## ✅ 요약 정리
![](https://velog.velcdn.com/images/sunmins/post/d7116ef1-5d64-430b-819f-b5228272b7cd/image.png)


| 구분     | TCP           | UDP           |
|----------|---------------|---------------|
| 연결방식 | 연결형        | 비연결형      |
| 전송순서 | 순서 보장     | 순서 보장 X   |
| 혼잡제어 | 있음 (O)      | 없음 (X)      |
| 속도     | 느림          | 빠름          |
| 신뢰성   | 높음          | 낮음          |


---

| 개념         | 설명                                                                 |
|--------------|----------------------------------------------------------------------|
| **TCP**       | 신뢰성 있는 데이터 통신을 위한 연결형 프로토콜                            |
| **UDP**             | 연결을 확인하지 않고 일방적으로 데이터를 전달하는 비연결형 프로토콜, 빠른 전송에 적합           |
| **시퀀스 번호** | 패킷이 순서대로 도착했는지 확인                                           |
| **플래그**     | 패킷 상태를 나타냄 (ACK, SYN, FIN 등)                                     |
| **3-way/4-way Handshake** | 연결 시작과 종료 시 수행되는 절차                                 |
| **흐름 제어**   | 수신자 속도에 맞춰 데이터 전송량 조절 (슬라이딩 윈도 등)                     |
| **혼잡 제어**   | 네트워크 혼잡 상황을 감지하고 속도 조절 (AIMD, 느린 시작 등)               |

---
