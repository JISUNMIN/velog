🆔 uuid는 **Universally Unique Identifier (범용 고유 식별자)**를 생성해주는 라이브러리입니다. 충돌 가능성이 거의 없기 때문에, 중복 걱정 없이 고유 값을 만들 수 있습니다.

🚀 사용 방법
>npm install uuid

```.js
import { v4 as uuidv4 } from 'uuid';

const id = uuidv4(); // 예: 'f5d3ff7e-e8c9-4c0a-ae78-b682fab087b0'
console.log(id);
```

### 🔢 주요 버전

| 버전   | 설명                                 |
| ---- | ---------------------------------- |
| `v1` | 시간 기반 (timestamp + MAC address 조합) |
| `v4` | 랜덤 기반 (가장 많이 쓰이는 버전) ✅             |
| `v5` | 네임스페이스 기반 (고정된 입력 → 고정된 UUID 생성 => 입력이 같으면 항상 같은 UUID 반환 (💡 ID 고정 목적에 유용))   |



보통 랜덤한 고유값이 필요할 때는 v4를 사용합니다.


### 💡 사용 예시
- 게시물, 댓글, 사용자 등에 클라이언트에서 임시 ID 생성
- **Optimistic UI**에서 임시 key 부여
- 캐시 key, 파일명, 세션 식별자 등에서 고유 값 생성

```.js
const newComment = {
  id: uuidv4(),
  text: '이 댓글은 Optimistic UI입니다.',
};

```

> ❓ Optimistic UI란? 결과가 아직 확정되지 않았지만, UI를 먼저 바꿔서 사용자에게 빠른 피드백을 주는 전략입니다.

📌 예시: 댓글 작성
// 사용자가 댓글 입력 후 "등록" 버튼을 누름
1. 클라이언트에서 댓글을 바로 UI에 추가 → uuid 등으로 임시 id 부여
2. 동시에 서버에 API 요청
3. 서버 응답 오면 진짜 ID로 교체 or 실패 시 롤백

✅ 핵심 포인트:
- uuid는 요청 파라미터에 포함되는 id를 의미하는게 아님
- 오직 UI에서 관리용으로 쓰는 임시 ID
- 서버 응답이 오면, 진짜 응답으로 온 ID로 덮어쓰기함

### ⚠️ 참고사항
- UUID는 보안용 토큰으로 사용하지 말 것 (ex. JWT 대체 불가) 
>✋이유:
uuid는 랜덤한 값을 생성할 수는 있지만,
암호화(Encryption)되거나 서명(Signed)되지 않은 문자열이기 떄문에
로그인 도큰, API 인증 키, 민감한 인증 정보에는 쓰면 안됩니다.

- UUID는 로컬에서 생성되므로, 중복 방지를 위해 서버에서도 확인 필요
> ✋이유: UUID는 거의 충돌이 없지만, 이론적으로는 0.0000000000000001%라도 중복 가능성이 있습니다. 그래서 서버에서도 해당 uuid가 존재하면 거절해야합니다.



### UUID 사용 예시

#### 예시 1. 댓글 작성할 때 임시 ID 생성 (Optimistic UI)

```js
import { v4 as uuidv4 } from 'uuid';

// 사용자가 댓글 작성 후 서버 응답을 기다리기 전에 임시로 화면에 보여줌
function addComment(text) {
  // 1. 클라이언트에서 임시 ID 생성
  const tempId = uuidv4();

  // 2. 임시 댓글 객체 생성
  const newComment = {
    id: tempId,
    text,
    status: 'pending' // 아직 서버 응답 대기 중
  };

  // 3. UI에 바로 반영 (서버 응답 기다리지 않고)
  comments.push(newComment);
  renderComments();

  // 4. 서버에 API 요청
  api.post('/comments', { text })
    .then(response => {
      // 5. 서버에서 받은 실제 ID로 임시 ID 교체
      const realId = response.data.id;
      const comment = comments.find(c => c.id === tempId);
      if (comment) {
        comment.id = realId;
        comment.status = 'confirmed';
        renderComments();
      }
    })
    .catch(() => {
      // 실패 시 임시 댓글 삭제 혹은 에러 표시
      comments = comments.filter(c => c.id !== tempId);
      renderComments();
      alert('댓글 작성 실패');
    });
}
```

#### 예시 2. 여러 서버나 클라이언트에서 동시에 생성해도 충돌 없는 ID 필요할 때

```js
import { v4 as uuidv4 } from 'uuid';

function createNewUser(name) {
  return {
    id: uuidv4(), // 전 세계에서 유일한 ID 생성
    name
  };
}

const user1 = createNewUser('Alice');
const user2 = createNewUser('Bob');

console.log(user1.id); // 예: 'f5d3ff7e-e8c9-4c0a-ae78-b682fab087b0'
console.log(user2.id); // 예: 'b1a94c54-3c7b-4f9b-8b0d-1c3d1f9d9d8a'
```

>✋설명: 
여러 사용자가 동시에 새 데이터를 만들 때, 각 데이터에 고유한 ID가 필요합니다.
만약 단순히 숫자를 1, 2, 3 식으로 증가시키면, 동시에 생성할 경우 ID가 겹칠 위험이 있습니다.
uuidv4() 함수는 전 세계 어디서나 중복될 확률이 거의 없는 고유한 문자열 ID를 생성합니다.
따라서 클라이언트나 여러 서버에서 동시에 데이터를 생성해도 ID 충돌 걱정 없이 안전하게 사용할 수 있습니다.
이 예시에서 createNewUser 함수는 새 사용자 객체를 만들 때, uuidv4()로 고유 ID를 자동으로 부여합니다.
이렇게 생성된 ID는 데이터베이스의 기본 키(primary key)로 사용하거나, 사용자 구분용으로 활용할 수 있습니다.


### ✅ 요약 정리
| 사용 상황                          | 설명                                    |
|---------------------------------|---------------------------------------|
| 서버에서 아직 ID를 안 내려줬을 때      | 서버 응답 전에 임시로 고유 ID를 생성해 UI에 바로 데이터 표시 가능           |
| 분산된 환경에서 고유 식별자가 필요할 때 | 여러 서버나 클라이언트에서 동시에 생성해도 중복 걱정 없는 식별자 필요           |
| 자동 증가 숫자 ID 대신 유니크 ID가 필요할 때 | 숫자 ID의 충돌이나 예측 가능성을 피하고 고유성이 보장되는 식별자가 필요한 경우         |


#### 🎯 클라이언트에서 중복 걱정 없이 고유 ID가 필요할 때 uuid를 사용할 수 있습니다.