## 1. JWT란?

JWT(JSON Web Token)는 로그인한 사용자를 인증하기 위해 서버가 발급하는 디지털 신분증 같은 토큰입니다.

- 가장 널리 쓰이는 토큰 방식입니다.
- 무상태(stateless) 인증에 적합해 서버 부하가 적음.
- JSON 형태로 되어 있습니다.
- 토큰 안에는 사용자 정보(예: id, role 등)가 들어있습니다.
- 암호화된 것은 아니지만, 서명되어 있어 변조 방지 기능이 있습니다.


### JWT 구조

xxxxx.yyyyy.zzzzz


| 파트       | 설명                                |
| --------- | --------------------------------- |
| Header    | 토큰 타입과 서명 알고리즘(`HS256` 등) |
| Payload   | 사용자 정보 같은 내용(`id`, `role`)     |
| Signature | 위 내용에 대해 비밀키로 서명한 값         |

---

## 2. JWT 서명 함수란?
![](https://velog.velcdn.com/images/sunmins/post/7cb88c77-cb71-4977-9e53-17e29d832a00/image.png)


"서명 함수"는 JWT를 만들어주는 함수입니다.  
즉, 사용자 정보(payload)를 받아 JWT 토큰 문자열을 만들어줍니다.

```ts
const token = signJwt({ id: 3, role: "USER" });
// token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...."
```

이 토큰을 클라이언트에게 주면,

클라이언트는 이 토큰을 이후 API 요청 시에 헤더에 붙입니다.

서버는 verifyJwt(token) 함수로 검증해 "이 토큰은 우리가 발급한 진짜 토큰이다"라고 확인합니다.


## 3.왜 JWT를 사용할까요?
| 기존 방식              | 문제점                            |
| ------------------ | ------------------------------ |
| 세션 저장 (서버 메모리에 저장) | 서버가 상태를 기억해야 하므로 확장성이 떨어집니다.   |
| JWT (Stateless)    | 서버가 상태를 기억하지 않아도 되어 확장성이 높습니다. |

즉, 서버가 사용자를 기억하지 않아도 되기 때문에 서버 부담이 줄고 구조가 더 유연해집니다.

## 4. JWT 발급 구조 요약
```
[로그인 요청]
    ↓
서버: ID/PW 확인
    ↓
서버: JWT 발급 (userId, role 등 포함)
    ↓
클라이언트: localStorage 혹은 cookie에 저장
    ↓
이후 모든 요청 시 Authorization: Bearer <token> 헤더로 전송
    ↓
서버는 토큰만으로 사용자 판별 가능
```

### 실제 발급 코드 예시

### 1. 토큰 생성

로그인 시 사용자 정보를 기반으로 JWT 토큰을 생성합니다.  
예를 들어, `signJwt()` 함수는 `id`, `userId`, `role` 등의 값을 payload에 담아 JWT를 발급합니다.

```ts
const token = signJwt({ id: 1, userId: "dd", role: "AUTH" });
```
![](https://velog.velcdn.com/images/sunmins/post/662ffb76-dad7-4dc3-bcd4-22b6811c5111/image.png)

### 2. 토큰 검증
모든 API 요청에는 인증을 위해 토큰 검증이 필요합니다.
해당 로직은 중복 사용되므로 공통 함수로 분리하여 관리합니다.

```ts
export function verifyJwt(token: string): UserPayload | null {
  try {
    return jwt.verify(token, process.env.JWT_SECRET!) as UserPayload;
  } catch (e) {
    return null;
  }
}
```
- req.cookies.get("token") 으로 쿠키에서 토큰을 추출하고,
- verifyJwt(token) 으로 유효성을 검증합니다.


![](https://velog.velcdn.com/images/sunmins/post/28ec8500-8ae7-41d1-8edf-32ff4d215e17/image.png)

![](https://velog.velcdn.com/images/sunmins/post/c63d7496-5fdc-49ab-b5e2-e35f952e70b1/image.png)

> **jsonwebtoken은 Node.js 환경에서 JWT(JSON Web Token)를 생성, 서명(sign), 검증(verify)하는 데 가장 많이 사용하는 대표적인 라이브러리입니다.**
 라이브러리를 통해 다음과 같은 기능을 쉽게 구현할 수 있습니다:
 - 토큰 생성(sign) const token = jwt.sign(payload, secret, options);
 - 토큰 검증(verify) const decoded = jwt.verify(token, secret);
 - 토큰 디코딩(decode) const decoded = jwt.decode(token);
 

### 3. 토큰에서 유저 정보 확인
JWT는 로그인 시 토큰에 넣었던 정보를 그대로 보존합니다.
검증 함수(verifyJwt)를 통해 payload 안의 유저 정보를 추출할 수 있습니다.
```ts
const token = 'roqwlkrowkrower';
const user = verifyJwt(token);

// 결과
{
  userId: 'dd',
  id: 1,
  role: 'AUTH'
}
```
따라서 서버는 토큰만으로 로그인 사용자의 신원 및 권한을 확인할 수 있습니다.
![](https://velog.velcdn.com/images/sunmins/post/b054f0d4-358d-4050-9195-e480828ba08e/image.png)







## 5. JWT의 유효기간(expiration)

JWT는 유효기간이 있어서 일정 시간이 지나면 로그인 상태가 자동으로 풀립니다.  
로그인을 한 번 하면 계속 유지되는 것은 부자연스러우니, 유효기간을 통해 주기적으로 로그아웃시키는 것이 자연스럽습니다.

```ts
jwt.sign(payload, secret, { expiresIn: "7d" });
```

위처럼 설정하면, 이 토큰은 7일 동안만 유효합니다.
7일 이후에는 이 토큰으로 API 요청 시 "만료됨" 에러가 발생합니다.
기본적으로 만료기간이 없습니다.

### JWT 동작 과정

| 상황      | 설명                              |
| ------- | ------------------------------- |
| 로그인 직후  | 서버가 토큰을 발급(7일 유효)               |
| 이후 요청   | 클라이언트가 이 토큰을 헤더에 붙여서 인증         |
| 7일 경과 후 | 서버는 "이 토큰 만료됨"으로 판단하여 로그인 해제 처리 |


## 6. 만료된 토큰 이후 처리 방법

- 유저는 다시 로그인해야 합니다. (기본 구조)

- 또는 "리프레시 토큰" 방식을 도입할 수 있습니다.

  - 액세스 토큰: 짧은 만료시간 (예: 15분)

  - 리프레시 토큰: 더 긴 유효기간 (예: 7일~30일)

- 액세스 토큰이 만료되면 리프레시 토큰으로 자동 갱신합니다.

- 리프레시 토큰은 보안 이슈 때문에 보통 데이터베이스에 저장하고, **httpOnly cookie**로 관리합니다.

---

## 7. 토큰 저장 방법: localStorage vs cookie

JWT 토큰은 클라이언트에서 다음 두 가지 방식 중 하나로 저장할 수 있습니다:

- **localStorage**
- **httpOnly cookie**

- 저는 **httpOnly cookie**로 저장했습니다.

### httpOnly cookie란?

- 일반 자바스크립트에서 접근 불가능한 쿠키입니다.

- 오직 서버에서만 읽고 쓸 수 있습니다.

- 클라이언트 자바스크립트가 직접 토큰을 탈취하거나 조작하는 것을 방지합니다.

### httpOnly cookie를 사용한 이유와 장점

- **보안 강화**: XSS(교차 사이트 스크립팅) 공격으로부터 토큰 탈취 위험이 줄어듭니다.

- **자동 전송**: 브라우저가 해당 도메인 요청 시 자동으로 쿠키를 포함해 전송해 주므로 토큰 관리를 편리하게 합니다.

- **토큰 노출 감소**: 클라이언트 자바스크립트에서 토큰을 직접 다루지 않으므로 토큰 노출 가능성을 줄입니다.


### 접근 가능 여부 비교

| 저장 위치            | 클라이언트 JS 접근 가능 여부 | 특징 |
|----------------------|------------------------------|------|
| `localStorage`       | ✅ 가능                         | 읽기/쓰기/삭제 자유 |
| `httpOnly cookie`    | ❌ 불가능                       | 서버만 접근 가능 (JS 접근 불가) |

---

### 접근 가능 시 (localStorage)의 장단점

✅ **장점**
- 클라이언트에서 토큰을 직접 확인하고 제어할 수 있음
- `Authorization` 헤더에 손쉽게 추가 가능
- 상태 관리, 로그인 여부 등을 클라이언트 측에서 제어하기 쉬움

❌ **단점**
- **XSS 공격에 노출**될 수 있음 → 악성 스크립트가 토큰을 탈취할 수 있음
- 브라우저 종료 전까지 토큰이 계속 남아 있을 수 있음

---

### 접근 불가능 시 (httpOnly cookie)의 장단점

✅ **장점**
- **보안 강화**: 클라이언트 JS가 접근할 수 없어 XSS에 강함
- **자동 전송**: 같은 도메인 요청 시 쿠키 자동 포함 (편리한 인증 처리)
- **토큰 노출 위험 감소**: JS 코드에 노출되지 않음

❌ **단점**
- 클라이언트에서 로그인 상태 여부를 직접 확인하기 어려움 → 별도 `/me` API 필요
- `fetch`, `axios` 요청 시 `credentials: 'include'` 설정 필수
- CSRF 방어 추가 고려 필요 (특히 상태 변경 요청 시)

---

### 요약

| 항목                 | localStorage       | httpOnly cookie         |
|----------------------|--------------------|--------------------------|
| JS 접근 가능 여부      | ✅ 가능             | ❌ 불가능                 |
| 보안성 (XSS 대비)      | ❌ 낮음             | ✅ 높음                   |
| API 요청 시 처리 방식  | 헤더에 직접 삽입 필요 | 자동 쿠키 포함 (CORS 설정 필요) |
| 로그인 상태 판별 방식 | 직접 토큰 확인 가능    | 서버 측 상태 확인 API 필요     |

---

### 권장 패턴

- 민감한 정보를 다룬다면 **httpOnly cookie** 방식이 보안적으로 더 안전합니다.
- **localStorage는 편리하지만 XSS 대응을 반드시 함께 고려**해야 합니다.
- 보안이 중요한 경우 `access token: 메모리`, `refresh token: httpOnly cookie` 방식도 자주 사용됩니다.



---

## ✅ 요약 정리

- JWT는 사용자 인증에 쓰이는 디지털 신분증 토큰입니다.

- JWT는 Header, Payload, Signature 세 부분으로 구성됩니다.

- 서버가 서명함수를 통해 토큰을 발급하며, 클라이언트가 인증 요청 시 토큰을 사용합니다.

- JWT는 Stateless 인증 방식으로 서버 확장성이 좋습니다.

- JWT는 유효기간이 있으며, 보안을 위해 주기적으로 만료됩니다.

- 만료 후 재인증하거나 리프레시 토큰 방식을 도입해 갱신할 수 있습니다.

- 토큰 저장은 보안과 편의성 때문에 httpOnly 쿠키를 많이 사용합니다.

