자바스크립트 코드가 실행될 때,
**변수는 어디서 접근되고**, **함수는 어떤 순서로 동작할까요?**

그 핵심에는 **스코프(Scope)** 와 **실행 컨텍스트(Execution Context)** 가 있습니다.
이 글에서는 자바스크립트의 **코드 실행 구조의 기반**이 되는 이 두 개념을 구체적인 예시로 살펴보겠습니다.

---

## 1️⃣ 스코프(Scope) - 변수에 접근할 수 있는 범위

스코프란 **식별자(변수, 함수 등)가 유효한 범위**를 의미합니다.
즉, "이 변수는 어디까지 쓸 수 있나?"를 결정하는 규칙입니다.

``` ts
let a = 10;

function foo() {
  let b = 20;
  console.log(a); //  외부 스코프 접근 가능
  console.log(b); // 내부 스코프 접근 가능
}

foo();
console.log(b); // ❌ ReferenceError (밖에서는 b를 모름)
```


> 안에서는 밖을 볼 수 있지만, 밖에서는 안을 볼 수 없습니다.

------------------------------------------------------------------------

## 2️⃣ 스코프의 종류

| 구분 | 설명 | 예시 |
|------|------|------|
| **전역 스코프** | 어디서든 접근 가능한 영역 | `var x = 10;` |
| **함수 스코프** | 함수 내부에서만 접근 가능 | `function foo() { let y = 20; }` |
| **블록 스코프** | `{}`로 구분되는 영역 (let/const 사용 시) | `if (true) { let z = 30; }` |


``` ts
if (true) {
  var a = 1;  // 함수 스코프
  let b = 2;  // 블록 스코프
}
console.log(a); // ✅
console.log(b); // ❌ ReferenceError
```

---

## 3️⃣ 렉시컬 스코프(Lexical Scope)

자바스크립트는 **렉시컬 스코프(정적 스코프)** 방식을 사용합니다.
즉, **함수가 정의된 위치**에 따라 스코프가 결정됩니다.
(함수를 “언제” 호출했는지가 아니라, **“어디서” 정의되었는지**가 중요합니다.)

### 📘 함수의 스코프 안에서 정의된 함수(중첩 함수)
``` ts
let x = 1;

function outer() {
  let x = 10;
  function inner() {
    console.log(x);
  }
  return inner;
}

const fn = outer();
fn(); // 🔹 10 (정의된 위치 기준)
```

### 📗 전역에서 정의된 함수
```ts
let x = 1;

function outer() {
  let x = 10;
  return inner; // ❗ 전역에 있는 inner 반환
}

function inner() {
  console.log(x);
}

const fn = outer();
fn(); // 🔹 1
```

> 자바스크립트는 렉시컬 스코프(정의된 위치 기준) 언어입니다.
>함수는 **“호출되는 시점”**이 아니라 **“선언된 시점의 환경(스코프)”**을 기억합니다.
> 이 구조 덕분에 클로저(Closure) 같은 개념이 가능해집니다.

---

## 4️⃣ 실행 컨텍스트(Execution Context) - 코드 실행의 단위

**실행 컨텍스트**는 자바스크립트 엔진이 **코드를 실행할 때마다 만들어지는 환경(메모리 공간)입니다. 
함수가 실행될 때마다 하나의 **실행 컨텍스트**가 생기며,  
그 안에는 **변수**, **스코프 연결 정보**, **this 정보**가 들어 있습니다.

> “자바스크립트 코드가 실행되는 순간 만들어지는 환경 정보 묶음”

---

### ⚙️ 실행 컨텍스트의 구성 요소

| 구성 요소 | 설명 | 쉬운 비유 |
|------------|------|-----------|
| ** Variable Environment (변수 환경)** | 현재 함수 안에서 선언된 **변수(var, let, const)** 와 **함수 선언문**을 저장하는 공간입니다. | 📦 “내 가방 안에 든 물건 리스트” |
| ** Lexical Environment (렉시컬 환경)** | **스코프 체인**을 관리합니다. 현재 스코프뿐 아니라 **상위 스코프(outer environment)** 와의 연결 정보를 가지고 있습니다. | 🗺️ “현재 방 + 복도로 이어진 방 지도” |
| ** This Binding (this 바인딩)** | 현재 실행 중인 함수에서 **this** 키워드가 가리키는 대상을 저장합니다. | 🪪 “나의 명함 (현재 소속 정보)” |

---
## 5️⃣ 실행 컨텍스트의 생성 과정

1.  **전역 컨텍스트 생성**
    -   자바스크립트가 처음 실행될 때 **자동으로 한 번 생성**
    -   전역 객체(`window` in 브라우저, `global` in Node.js)에 바인딩
2.  **함수 호출 시 새로운 컨텍스트 생성**
    -   **함수가 호출될 때마다** 새로운 실행 컨텍스트가 만들어짐
    -   각 함수는 **독립적인 실행 환경**을 가지며, 실행이 끝나면 메모리에서 제거
3.  **스택 구조로 관리**
    -   가장 최근에 호출된 함수가 맨 위에 쌓이고,
        실행이 끝나면 스택에서 빠져나감.

### 🧩 실행 컨텍스트 스택 구조

> 실행 컨텍스트는 **스택(Stack)** 형태로 쌓입니다.  
> 즉, “나중에 호출된 함수가 먼저 끝나야” 이전 함수로 돌아갑니다.  
> (LIFO — Last In, First Out)

### 📘 함수 호출 관계가 있는 경우
``` ts
function first() {
  console.log("first");
  second();
}

function second() {
  console.log("second");
}

first();

// 실행 순서: Global → first() → second() → second() 종료 → first() 종료 → Global
```


 💡 **참고**  
> 모든 함수가 이런 식으로 “안에 안 들어가며” 쌓이는 건 아닙니다.  
> 위 예시는 `first()` 안에서 `second()`를 호출했기 때문에  
> `second()`가 스택의 맨 위에 올라가 **먼저 실행되고 종료된 것**입니다.
>
> 만약 두 함수가 **서로 독립적으로 호출**된다면  
> 각각 실행 후 바로 스택에서 빠져나가며,  
> 이런 중첩 구조는 생기지 않습니다.

### 📗 함수들이 서로 독립적으로 호출될 때
```ts
function first() { 
  console.log("first"); 
}

function second() { 
  console.log("second"); 
}

second();
first();

// 실행 순서: Global → second() → second() 종료 → first() → first() 종료 → Global
```

즉,
**“호출 관계가 있을 때만” 스택이 중첩**되고,
**“독립된 호출”이라면 순서대로 실행 후 바로 종료됩니다.**

### 🧠 정리하자면:
실행 컨텍스트는 자바스크립트의 “실행 단위 상자”로,
코드 실행 시마다 만들어지고, 스택 형태로 쌓였다가
실행이 끝나면 사라집니다

---

## 6️⃣ 스코프 체인(Scope Chain)

스코프 체인은 **변수를 찾을 때** 사용되는 연결 구조입니다.
현재 스코프에 변수가 없으면, **상위 스코프로 거슬러 올라가며 검색**합니다.

>스코프 체인은 변수를 찾는 탐색 경로
“현재 스코프 → 상위 스코프 → 전역 스코프” 순으로 검색

```text
[inner]  →  [outer]  →  [global]
   ↑           ↑           ↑
현재 스코프   한 단계 위    최상위
```

 변수를 찾을 때, 이렇게 연결된 **사슬(chain)** 을 따라  “**안쪽에서 바깥쪽으로**” 올라갑니다.  
이 연결 정보는 실행 컨텍스트 안의 **Lexical Environment** 에 저장됩니다.

``` ts
const x = "global";

function outer() {
  const x = "outer";
  function inner() {
    console.log(x);
  }
  inner();
}

outer(); // "outer"
```

내부 스코프는 외부 스코프를 "참조"할 수 있지만,  반대로는 불가능합니다.

### ⚠️ 스코프 체인을 따라가도 변수를 못 찾는 경우
```ts
function test() {
  console.log(a);
}

test(); // ❌ ReferenceError: a is not defined
```
- `test()` 내부에 `a` 없음  
- 상위 스코프(전역)에도 `a` 없음  
- 결국 **스코프 체인의 끝까지 올라가도 `a`를 찾지 못해**  **ReferenceError** 가 발생합니다.

>### 💡 ReferenceError란?
**ReferenceError** 는 “참조(reference)”하려는 대상(변수나 함수 등)을 자바스크립트 엔진이 **찾을 수 없을 때 발생하는 오류**입니다.

---

## 💬 마무리

자바스크립트의 **스코프(Scope)** 와 **실행 컨텍스트(Execution Context)**
는 코드가 실행되는 **기본 메커니즘**입니다.

> 스코프는 "변수를 찾는 규칙"을,
> 실행 컨텍스트는 "코드를 실행하는 환경"을 정의합니다.

이 개념을 토대로 호이스팅, 클로저, this 바인딩 등
자바스크립트의 복잡한 동작 원리도 이해할 수 있습니다.
