<p>기존에는 상품 검색 API에서 <strong>Prisma의 <code>findMany</code> + <code>where</code> 조건</strong>을 사용해 검색을 구현하고 있었습니다.</p>
<p>이 방식은 구현이 간단하고 Prisma ORM의 장점을 그대로 활용할 수 있었지만,<br />실제 서비스를 사용하다 보니 <strong>공백이 조금만 달라도 검색되지 않는 문제</strong>가 발생했습니다.</p>
<p>예를 들어 DB에는<br /><code>배달로봇 딜리버리 원</code><br />이라고 저장된 상품이 있을 때,</p>
<p>사용자가<br /><code>배달로봇딜리</code><br />처럼 <strong>공백 없이 검색하면 결과가 나오지 않았습니다.</strong></p>
<p><img alt="" src="https://velog.velcdn.com/images/sunmins/post/3e8c9b4a-717b-4af6-8eea-f03cfc86c0e0/image.png" /></p>
<p>사용자 입장에서는 같은 단어로 인식되지만,<br />검색 결과가 나오지 않아 <strong>검색 사용성이 크게 떨어지는 문제</strong>였습니다.</p>
<p>이 글에서는 왜 이런 문제가 발생했는지와 Prisma 검색 방식의 한계는 무엇인지<br />이를 어떻게 해결했는지 정리해보았습니다.</p>
<hr />
<h2 id="💡-왜-문제가-발생했을까">💡 왜 문제가 발생했을까?</h2>
<h3 id="기존-prisma-검색-방식의-한계">기존 Prisma 검색 방식의 한계</h3>
<p>기존 검색 코드는 다음과 같은 Prisma 조건을 사용하고 있었습니다.</p>
<pre><code class="language-ts">{
  name: { path: [&quot;ko&quot;], string_contains: search }
}</code></pre>
<p>이 코드는 내부적으로 다음과 같은 SQL로 변환됩니다.</p>
<pre><code class="language-sql">name-&gt;&gt;'ko' LIKE '%검색어%'</code></pre>
<hr />
<h3 id="🔍---와-path-는-무엇일까">🔍 <code>-&gt;&gt;</code> 와 <code>path</code> 는 무엇일까?</h3>
<h4 id="---postgresql-json-연산자"><code>-&gt;&gt;</code> : PostgreSQL JSON 연산자</h4>
<p>PostgreSQL에서 JSON/JSONB 컬럼을 다룰 때 사용하는 연산자입니다.</p>
<p>JSON은 객체(<code>{}</code>)만 의미하는 것이 아니라,<br />문자열, 숫자, 배열도 모두 JSON 값에 포함됩니다.</p>
<pre><code class="language-json">&quot;아메리카노 라떼&quot;</code></pre>
<p>위 값 역시 <strong>JSON 문자열 타입</strong>입니다.</p>
<pre><code class="language-json">{
  &quot;ko&quot;: &quot;아메리카노 라떼&quot;,
  &quot;en&quot;: &quot;Americano Latte&quot;
}</code></pre>
<h4 id="name-ko-json-타입"><code>name-&gt;'ko'</code> (JSON 타입)</h4>
<pre><code class="language-sql">SELECT name-&gt;'ko' FROM product;</code></pre>
<p>결과:</p>
<pre><code class="language-json">&quot;아메리카노 라떼&quot;</code></pre>
<ul>
<li>JSON 타입</li>
<li>문자열 함수 사용 불가</li>
</ul>
<h4 id="name-ko-text-타입"><code>name-&gt;&gt;'ko'</code> (TEXT 타입)</h4>
<pre><code class="language-sql">SELECT name-&gt;&gt;'ko' FROM product;</code></pre>
<p>결과:</p>
<pre><code class="language-text">아메리카노 라떼</code></pre>
<ul>
<li>TEXT 타입</li>
<li><code>LIKE</code>, <code>ILIKE</code>, <code>regexp_replace</code> 사용 가능</li>
</ul>
<p>검색에서는 문자열 함수가 필요하므로 -&gt;&gt;를 사용해야 합니다.</p>
<hr />
<h3 id="path-는-무엇인가"><code>path</code> 는 무엇인가?</h3>
<p>Prisma의 <code>path</code> 옵션은
<strong>JSON 필드 안에서 어떤 키를 대상으로 검색할지 지정하는 역할</strong>을 합니다.</p>
<pre><code class="language-ts">{ name: { path: [&quot;ko&quot;], string_contains: search } }</code></pre>
<p>name(JSON) 안에 있는 ko 키의 문자열에서
search가 포함되어 있는지 검사합니다.</p>
<hr />
<h2 id="❗-문제의-핵심">❗ 문제의 핵심</h2>
<p>Prisma의 <code>string_contains</code>는  
<strong>문자열을 가공하지 않고 그대로 비교</strong>합니다.</p>
<p>공백 역시 하나의 문자이기 때문에</p>
<ul>
<li><code>배달로봇 딜리버리 원</code></li>
<li><code>배달로봇딜리버리원</code></li>
</ul>
<p>은 서로 <strong>다른 문자열</strong>로 인식됩니다.</p>
<p>이는 Prisma의 버그가 아니라<br /><strong>설계상 정상적인 동작</strong>입니다.</p>
<hr />
<h2 id="🎯-목표">🎯 목표</h2>
<p>저는 다음과 같은 방향으로 문제를 해결하고 싶었습니다</p>
<ul>
<li>검색어와 DB 값의 <strong>공백 차이 무시</strong></li>
<li>붙여 쓴 검색어 / 띄어 쓴 검색어 모두 검색 가능</li>
<li>검색 사용성 개선</li>
</ul>
<p>이를 위해 문자열 비교 전에<br /><strong>공백을 제거하는 방식</strong>을 선택했습니다.</p>
<hr />
<h2 id="🔄-변경-전-코드-prisma-findmany">🔄 변경 전 코드 (Prisma <code>findMany</code>)</h2>
<pre><code class="language-ts">const and: Prisma.ProductWhereInput[] = [];

if (search) {
  and.push({
    OR: [
      { name: { path: [&quot;ko&quot;], string_contains: search } },
      { description: { path: [&quot;ko&quot;], string_contains: search } },
      { name: { path: [&quot;en&quot;], string_contains: search } },
      { description: { path: [&quot;en&quot;], string_contains: search } },
    ],
  });
}

if (and.length &gt; 0) where.AND = and;</code></pre>
<hr />
<h2 id="🔄-변경-후-코드-prisma-queryraw">🔄 변경 후 코드 (Prisma <code>$queryRaw</code>)</h2>
<p>Prisma ORM 대신<br />PostgreSQL의 문자열 함수(<code>regexp_replace</code>)를 사용하는<br /><strong>Raw SQL 방식</strong>으로 변경했습니다.</p>
<blockquote>
<p>RAW SQL이란?</p>
<p>Raw SQL은 ORM이 아닌
SQL 문을 직접 작성해 DB에 실행하는 방식입니다.
Prisma가 제공하지 않는 DB 기능 사용 가능
복잡한 문자열 처리 가능
대신 타입 안정성은 직접 관리해야 함</p>
</blockquote>
<p>문자열 가공이 필요했기 때문에 사용하게 되었습니다.</p>
<hr />
<h2 id="🔧-변경-사항-정리">🔧 변경 사항 정리</h2>
<h3 id="1️⃣-prisma-모델명과-실제-테이블명">1️⃣ Prisma 모델명과 실제 테이블명</h3>
<p>Prisma 모델명과 실제 DB 테이블명은<br /><code>@@map</code> 설정에 따라 다를 수 있습니다.</p>
<p>이를 안전하게 처리하기 위해<br />Prisma의 메타데이터(DMMF)를 사용했습니다.</p>
<pre><code class="language-ts">function getTableName(modelName: string) {
  const model = Prisma.dmmf.datamodel.models.find(
    (m) =&gt; m.name === modelName
  );
  return model?.dbName ?? modelName;
}</code></pre>
<p>혹은 schema.prisma에서 @@map(&quot;...&quot;)에 지정한 테이블명을 직접 사용해도 됩니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/sunmins/post/fafc6a74-8f0b-4ff9-91e2-f638927a1857/image.png" /></p>
<hr />
<h3 id="2️⃣-검색어-공백-정리-trim-vs-replace">2️⃣ 검색어 공백 정리 <code>trim</code> vs <code>replace</code></h3>
<pre><code class="language-ts">const normalize = (s: string) =&gt; s.trim().replace(/\s+/g, &quot; &quot;);</code></pre>
<ul>
<li><code>trim()</code> : <strong>앞뒤 공백</strong>만 제거</li>
<li><code>replace(/\s+/g, &quot; &quot;)</code> : 중간 공백(여러 개, 탭, 줄바꿈)을 <strong>한 칸으로 정리</strong></li>
</ul>
<pre><code class="language-ts">const qNoSpace = searchRaw.replace(/\s+/g, &quot;&quot;);</code></pre>
<p>→ 검색 비교를 위해 <strong>모든 공백 완전 제거</strong></p>
<hr />
<h3 id="3️⃣-db-문자열-공백-제거">3️⃣ DB 문자열 공백 제거</h3>
<p>PostgreSQL의 <code>regexp_replace</code>를 사용해
DB에 저장된 문자열에서도 모든 공백을 제거합니다.</p>
<pre><code class="language-ts">const stripSpaceSql = (expr: Prisma.Sql) =&gt;
  Prisma.sql`
    regexp_replace(
      COALESCE(${expr}, ''),
      '\\s+',
      '',
      'g'
    )
  `;</code></pre>
<blockquote>
<p>regexp_replace(원본문자열, '찾을패턴', '바꿀문자열', '옵션')</p>
</blockquote>
<ul>
<li>COALESCE : NULL이 아닌 첫 값을 찾는 SQL 함수 </li>
<li>\s+ : 모든 공백</li>
<li>'' : 공백 제거</li>
<li>'g' : 전체 적용</li>
</ul>
<hr />
<h3 id="4️⃣-대소문자-무시-검색-ilike">4️⃣ 대소문자 무시 검색 (ILIKE)</h3>
<pre><code class="language-ts">conditions.push(Prisma.sql`
  (
    ${stripSpaceSql(Prisma.sql`name-&gt;&gt;'ko'`)} ILIKE ${like}
    OR ${stripSpaceSql(Prisma.sql`description-&gt;&gt;'ko'`)} ILIKE ${like}
    OR ${stripSpaceSql(Prisma.sql`name-&gt;&gt;'en'`)} ILIKE ${like}
    OR ${stripSpaceSql(Prisma.sql`description-&gt;&gt;'en'`)} ILIKE ${like}
  )
`);
</code></pre>
<hr />
<h2 id="✅-구현-결과">✅ 구현 결과</h2>
<p><img alt="" src="https://velog.velcdn.com/images/sunmins/post/d904884b-18a2-487b-97d7-9ed38e242386/image.png" /></p>
<h2 id="📝-마무리">📝 마무리</h2>
<ul>
<li>Prisma의 <code>string_contains</code>는 문자열을 그대로 비교한다</li>
<li>공백 차이가 있으면 검색되지 않는다</li>
<li>이는 Prisma의 한계이며 버그가 아니다</li>
</ul>