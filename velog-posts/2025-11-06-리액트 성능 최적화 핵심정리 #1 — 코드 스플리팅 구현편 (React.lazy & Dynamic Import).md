## 1️⃣ 코드 스플리팅이란?

**코드 스플리팅(Code Splitting)**은 애플리케이션의 자바스크립트 코드를 여러 개의 작은 청크(chunk)로 나누는 기법입니다.  
한 번에 모든 코드를 불러오는 대신, **필요한 시점에 필요한 코드만 로드**하도록 만들어 초기 로딩 속도를 개선합니다.

>  “처음부터 모든 걸 다 가져오지 말고, 쓸 때만 가져오자”는 개념.

---

## 2️⃣ 코드 스플리팅의 필요성

- SPA(Single Page Application)는 번들 크기가 커질수록 **초기 로딩 속도**가 느려집니다.  
- 코드 스플리팅을 적용하면 **불필요한 코드가 초기 번들에 포함되지 않아** 첫 진입 속도를 줄일 수 있습니다.  
- 또한 **페이지 이동 시점에 필요한 코드만 불러오므로**, 체감 성능과 사용자 경험이 크게 향상됩니다.

---

## 3️⃣ Dynamic Import — 코드 스플리팅의 기본 원리

React의 코드 스플리팅은 사실상 **자바스크립트 표준 문법 `import()`**를 기반으로 합니다.  
이 함수형 import는 Webpack이나 Vite가 인식해 **코드를 자동으로 청크 단위로 분리**합니다.

```jsx
// 동적 로드 예시
async function onClick() {
  const { Chart } = await import('chart.js'); // 필요할 때만 로드
  new Chart(ctx, config);
}
```
---

1. 처음 `import()` 호출 시
```tsx
const { Chart } = await import('chart.js');
```
- 브라우저가 chart.js 청크 파일을 네트워크로 요청하고 다운로드합니다.
- Webpack/Vite가 런타임에 해당 모듈을 __webpack_require__ 또는 import() 캐시에 등록합니다.
- 그 결과, Chart 클래스가 현재 실행 컨텍스트에 로드됩니다.

> “청크(chunk)”: 코드 스플리팅으로 분리된 자바스크립트 코드 조각

2. 이후 동일한 모듈 import() 호출 시
```tsx
const { Chart } = await import('chart.js'); // 두 번째 호출
```
- 브라우저는 네트워크 요청을 다시 보내지 않습니다.
- 이미 메모리에 올라간 Chart 모듈을 즉시 반환합니다.
- 즉, Promise가 즉시 resolve됩니다.

3. 메모리에서 사라질 때
- 사용자가 **페이지를 새로고침하거나, 탭을 닫을 때**, 브라우저의** JS 런타임이 초기화**됩니다.
- 이때 `import()`로 로드된 모듈 캐시(import cache)도 함께 제거됩니다.
- 따라서 앱이 종료되기 전까지는 메모리에 유지되지만, 새로고침 또는 완전한 페이지 이동 시에는 다시 로드가 필요합니다.

### 💡 참고 : [페이지 이동 시의 동작 차이](https://velog.io/@sunmins/React-SPA-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)

| 구분                                               | 설명                                        | 메모리 캐시 유지 여부 |
| ------------------------------------------------ | ----------------------------------------- | ------------ |
| **SPA 내부 이동 (React Router 등)**                   | URL만 바뀌고 페이지 전체는 새로 로드되지 않음. JS 런타임이 유지됨. | ✅ 유지됨        |
| **브라우저 새로고침(F5)**                                | 현재 문서를 새로 불러오며 JS 런타임이 재시작됨.              | ❌ 초기화됨       |
| **완전한 페이지 이동 (`window.location.href`, `<a href>`,  외부 링크 등)** | 새로운 문서를 불러오며 기존 런타임 종료                    | ❌ 초기화됨       |
| **탭 종료 후 재진입**                                   | 탭이 닫히면 런타임이 완전히 해제되고, 다시 열면 새로 시작         | ❌ 초기화됨       |

즉,** SPA 내부 라우팅에서는 메모리에 남지만**,
**새로고침이나 완전한 이동에서는 런타임이 초기화**되어 import 캐시가 사라집니다.


---

## ✅ 정리

- Dynamic Import(`import()`)를 사용하면 번들러가 “이건 동적 로딩이네?” 하고 감지 
-  import() 부분을 별도의 JS 파일(청크)로 분리해서 dist/ 폴더에 생성
-  사용자가 해당 코드를 실행할 때(예: 버튼 클릭) 그 청크를 네트워크로 요청해서 불러옴
-  다운로드된 모듈은 메모리에 캐시되어, 같은 모듈을 다시 요청해도 즉시 사용 가능

즉, **Dynamic Import(import())를 사용하면, 번들러가 그 부분을 자동으로 “별도 청크로 분리”해서 빌드**해두고, **런타임에 그 청크를 네트워크로 불러와 실행**합니다.


| 구분 | 시점 | 특징 |
| -- | -- | -- |
| `import` | 빌드 시점 | 항상 미리 불러옴 (정적 로드) |
| `import()` | 실행 시점 | 조건 충족 시점에만 불러옴 (동적 로드) |

> 💡 `import()`는 모든 코드 스플리팅의 기반입니다.  
> React의 `React.lazy`, 라우터 분리, 컴포넌트 단위 로딩 등은 전부 이 원리를 활용합니다.

---

## 4️⃣ 컴포넌트 단위 코드 스플리팅 — React.lazy + Suspense

`React.lazy`는 `import()`를 **React 컴포넌트 단위로 감싸주는 함수**입니다.  
이를 통해 필요한 컴포넌트를 **지연 로딩(lazy load)** 하면서도 로딩 상태를 `Suspense`로 쉽게 제어할 수 있습니다.

```jsx
import React, { Suspense } from 'react';

const MyComponent = React.lazy(() => import('./MyComponent'));

function App() {
  return (
    <Suspense fallback={<div>로딩 중...</div>}>
      <MyComponent />
    </Suspense>
  );
}
```
---

## React.lazy의 역할 — 컴포넌트를 동적으로 import()

`React.lazy()`는 사실상 `import()`를 **React가 이해할 수 있는 “컴포넌트 형태”로 감싸주는 함수**입니다.

즉, 다음 코드는 
```tsx
const MyComponent = React.lazy(() => import('./MyComponent'));
```

```tsx
async function onDemandLoad() {
  const module = await import('./MyComponent'); // 청크 파일 다운로드
  return module.default; // 기본 내보낸 컴포넌트 반환
}
```
즉, 일반 `import()`는 **모듈을 반환**하지만,
`React.lazy()`는 그 결과를 **React 컴포넌트처럼 렌더링할 수 있도록 포장**합니다.
“import를 컴포넌트 단위로 감싼다”는 말은 
import()된 모듈을 React가 `<MyComponent />` 형태로 다룰 수 있게 만든다는 뜻입니다.

## Suspense의 역할 — 로딩 상태 관리
`React.lazy`로 가져오는 컴포넌트는 비동기적으로 로드되기 때문에,
로딩이 완료되기 전까지 화면에 아무것도 보여줄 수 없습니다.

이때 **로딩 중 상태를 대신 보여주는 역할**을 하는 게 바로 `Suspense`입니다.

```tsx
<Suspense fallback={<div>로딩 중...</div>}>
  <MyComponent />
</Suspense>
```
- `fallback`은 컴포넌트가 아직 로드되지 않았을 때 보여줄 UI입니다.
- import()가 끝나면 자동으로 실제 컴포넌트로 전환됩니다.
- `Suspense`는 비동기로 불러오는 컴포넌트의 로딩 상태를 감싸서 관리하는 컨테이너입니다.

### 실제 동작 순서
1. `<MyComponent />` 렌더링 시 React가 `React.lazy()` 내부의 `import()`를 실행
2. 아직 다운로드가 안 됐다면 → `Suspense`의 `fallback`이 표시됨
3. 모듈 다운로드 완료 → React가 해당 컴포넌트를 로드 후 렌더링

---

## 조건부 로딩 (버튼 클릭 시 import)

항상 렌더링 시점에 불러오지 않고,
사용자가 버튼을 눌렀을 때만 컴포넌트를 로드할 수도 있습니다.

```tsx
import React, { useState, Suspense } from 'react';

const Chart = React.lazy(() => import('./Chart'));

export default function Dashboard() {
  const [show, setShow] = useState(false);

  return (
    <div>
      <button onClick={() => setShow(true)}>차트 보기</button>

      {show && (
        <Suspense fallback={<div>차트를 불러오는 중...</div>}>
          <Chart />
        </Suspense>
      )}
    </div>
  );
}

```
- 버튼을 누르기 전까지는 `Chart.js` 파일이 네트워크 요청되지 않음
- 클릭 시 `import()`가 실행되고, 로딩 중에는 `fallback`이 표시됨
- 필요한 순간에만 JS를 다운로드하므로 **불필요한 초기 로딩 방지**

---
### 💡 참고: 프리로드 (hover 시 미리 다운로드)

호버(hover) 또는 포커스(focus) 시점에 미리 다운로드를 걸어두면
클릭할 때 체감 속도가 훨씬 빨라집니다.

```tsx

const Chart = React.lazy(() => import('./Chart'));

//“미리 불러오기(preload)”용 커스텀 헬퍼 코드
React의 React.lazy에는 기본적으로 “미리 로드(prefetch)” 기능이 내장되어 있지 않기 때문에,
이렇게 직접 import()를 실행하는 함수를 붙여서
원할 때(예: hover, focus, scroll 시점)에 청크를 미리 다운로드하도록 하는 트릭
Chart.preload = () => import('./Chart');

<button
  onMouseEnter={() => Chart.preload?.()}
  onFocus={() => Chart.preload?.()}
  onClick={() => setShow(true)}
>
  차트 보기
</button>

```

---



### ✅ 특징 요약
- 내부적으로 `import()` 기반으로 동작합니다.  
- `import()`는 단순히 코드를 불러오는 문법이고, `React.lazy` + `Suspense`는 그 과정을 **React 렌더링 흐름(UI)** 안에 연결해주는 기술입니다.
- 불필요한 초기 로드를 방지하고 **컴포넌트 단위로 효율적 분리**가 가능합니다.

> 💬 **정리:** `React.lazy` + `Suspense`는 “React식 코드 스플리팅 표준 조합”입니다.

---

## 5️⃣ 라우트 단위 코드 스플리팅 — 페이지별 코드 분리

React Router를 사용하면 **페이지 이동 시점에만 해당 페이지의 코드를 불러오도록** 구성할 수 있습니다.  
즉, 사용자가 어떤 페이지로 이동하기 전까지는 그 페이지의 JS 청크를 다운로드하지 않습니다.

```jsx
import { lazy, Suspense } from 'react';
import { BrowserRouter, Route, Routes } from 'react-router-dom';

const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));

export default function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>로딩 중...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

- `Home`과 `About`은 각각 별도의 **청크 파일**로 빌드됩니다.
- 사용자가 `/`로 접속하면 `Home`만 로드됩니다.
- `/about`으로 이동하면 그때서야 `About.js` 청크가 네트워크로 요청됩니다.
- React가 해당 모듈을 메모리에 로드하고 화면을 갱신합니다.

첫 페이지는 빠르게 로드되고, 이후 페이지는 필요할 때만 청크를 요청합니다. 

---
## 라우트 단위 코드 스플리팅 vs 컴포넌트 단위 코드 스플리팅

| 구분         | 라우트 단위 코드 스플리팅                            | 컴포넌트 단위 코드 스플리팅                           |
| ---------- | ----------------------------------------- | ----------------------------------------- |
| **단위 기준**  | 페이지(Route)                                | 특정 UI 컴포넌트                                |
| **언제 로드됨** | 페이지 이동 시                                  | 컴포넌트 렌더링 시                                |
| **적용 위치**  | `<Route>` 내부                              | JSX 내부 (페이지 안쪽)                           |
| **사용 목적**  | 초기 로딩 최소화                                 | 부분 기능만 늦게 불러오기                            |
| **예시**     | `/home`, `/about`                         | Chart, Editor, Modal 등                    |
| **공통점**    | `import()` + `React.lazy` + `Suspense` 사용 | `import()` + `React.lazy` + `Suspense` 사용 |



## 6️⃣ 실전 예시 — 페이지 & 컴포넌트 병합형 코드 스플리팅

대규모 React 앱에서는 보통 **페이지 단위(라우트 기준)** 와  
**컴포넌트 단위(UI 위젯 기준)** 코드 스플리팅을 **함께 적용**합니다.

예를 들어 다음 코드는  
- 라우트별로 페이지(`pages/Dashboard`)를 lazy 로 분리하고  
- 페이지 내부에서 무거운 UI 컴포넌트(`components/ChartWidget`)를 또 따로 분리하는 구조입니다.

```jsx
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

// ✅ 라우트 단위 코드 스플리팅
const DashboardPage = lazy(() => import('./pages/Dashboard'));
const SettingsPage = lazy(() => import('./pages/Settings'));

// ✅ 컴포넌트 단위 코드 스플리팅 (대시보드 내부에서 사용)
const ChartWidget = lazy(() => import('./components/ChartWidget'));

export default function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>페이지 로딩 중...</div>}>
        <Routes>
          <Route
            path="/"
            element={
              <DashboardPage>
                <Suspense fallback={<div>차트 로딩 중...</div>}>
                  <ChartWidget />
                </Suspense>
              </DashboardPage>
            }
          />
          <Route path="/settings" element={<SettingsPage />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```
| 시점 | 상태                           | 화면에 보이는 것                          |
| -- | ---------------------------- | ---------------------------------- |
| T0 | `/` 진입, DashboardPage 다운로드 중 | ⚙️ “페이지 로딩 중...”                   |
| T1 | DashboardPage 로드 완료          | ✅ Dashboard UI, ⚙️ “차트 로딩 중...”    |
| T2 | ChartWidget 로드 완료            | ✅ Dashboard UI + ChartWidget 표시 |

“페이지는 먼저 뜨고, 내부 위젯은 나중에 따라오는” **점진적 렌더링(Progressive Rendering)** 구조입니다.
Suspense를 중첩 사용해 페이지와 위젯의 로딩 단위를 분리함으로써,
**빠른 초기 응답성과 부드러운 사용자 경험**을 동시에 얻을 수 있습니다.

---

## 7️⃣ 라이브러리 단위 분리 (예: Lodash, Chart.js 등)

```tsx
const loadChart = async () => {
  const { Chart } = await import('chart.js');
  new Chart(ctx, config);
};
```
- 무거운 서드파티 라이브러리를 특정 기능에서만 동적으로 로드할 수 있습니다.  
- 전체 번들 크기를 줄이고, 사용자 요청 시에만 불러오는 전략입니다.

> **“서드파티(Third-party)”**: 내가 직접 만든 코드가 아닌, 외부에서 가져와 사용하는 코드나 라이브러리
예: React, Lodash, Axios, Chart.js 등

### 활용 예시 
```tsx
async function handleData() {
  const { uniq } = await import('lodash'); // 필요할 때만 Lodash 로드
  const result = uniq([1, 2, 2, 3, 4, 4]);
  console.log(result); // [1, 2, 3, 4]
}
```
Lodash는 기능이 방대해서 라이브러리 용량이 큽니다. 그런데 실제로는 그 중 일부 함수만 사용하는 경우가 많습니다.
예를 들어,“uniq 함수 하나만 쓸 건데 전체 Lodash를 번들에 포함하는 건 비효율적”입니다.
이럴 땐 Dynamic Import(import()) 로 필요한 순간에만 로드할 수 있습니다.
Lodash를 앱 전체 번들에 포함하지 않고, handleData()가 호출되는 시점에만 네트워크로 불러옵니다.

브라우저는 이후 이 모듈을 메모리에 캐싱하므로,
다음 번 호출 시에는 즉시 실행됩니다.

---

## 8️⃣ 코드 스플리팅을 적용하면 좋은 상황

✅ **규모가 큰 SPA** — 초기 번들 크기를 줄여 첫 진입 속도 개선  
✅ **라우트가 뚜렷한 앱** — 페이지별 코드 분리로 필요한 시점에만 로드  
✅ **무거운 서드파티 라이브러리** 일부만 사용할 때 — Lodash, Chart.js 등  
✅ **모바일 환경** — 네트워크 자원이 제한적일 때 효과적  
✅ **캐싱 효율을 높이고 싶을 때** — 청크 단위로 분리되어, 변경된 부분만 다시 다운로드

---

## 9️⃣ 코드 스플리팅의 한계 및 주의점

❌ **너무 잘게 쪼개면** HTTP 요청 수가 증가해 오히려 로딩이 느려질 수 있음  
❌ **청크 간 의존성이 복잡해지면** 캐싱 관리와 디버깅이 어려워짐  
❌ **빈번한 전환 없는 앱**과 **사용 빈도가 낮은 앱**에서는 스플리팅의 체감 이득이 크지 않음  
❌ **SSR(Server Side Rendering)** 환경에서는 `React.lazy`를 바로 사용할 수 없어 추가 설정 필요

> 💡 핵심은 **“코드를 얼마나 나누느냐”보다 “언제 불러오느냐를 제어하는 것”**입니다.  
> 즉, **총 다운로드 양은 같지만 시점을 분리해 사용자 체감 속도를 최적화**하는 것이 목표입니다.

---

##  최종 정리

| 구분 | 적용 방식 | 장점 | 주의점 |
|------|------------|------|--------|
| **Dynamic Import** | 실행 시점에 모듈 로드 | 초기 번들에서 제외, 필요한 시점에만 로드 | 첫 호출 시 지연 발생 |
| **React.lazy + Suspense** | 컴포넌트 단위 로드 | 선언적 문법, 로딩 UI(`fallback`) 제공 | SSR 환경 제약 |
| **라우트 단위 스플리팅** | 페이지별 코드 분리 | UX 향상, 트래픽 절약 | 초기 라우트 전환 시 로딩 표시 |
| **라이브러리 단위 분리** | 무거운 서드파티만 분리 | 불필요한 라이브러리 제거, 캐싱 효율 증가 | 사용 시점에 지연 가능 |
| **청크 단위 캐싱** | Webpack/Vite 자동 관리 | 변경된 청크만 재다운로드 | 너무 많은 청크는 관리 복잡 |

---

## 💬 마무리

코드 스플리팅은 단순히 “코드를 쪼개는 기술”이 아니라  
**다운로드 시점과 캐싱 효율을 제어해 초기 속도를 최적화하는 전략**입니다. 

 React 성능 최적화의 핵심 중 하나입니다.  
초기 로딩 속도, 사용자 경험, 유지보수성 모두에 긍정적인 영향을 줍니다.  

> “한 번에 다 받지 말고,  
> 필요한 시점에 필요한 코드만 가져오자.”  


처음부터 모든 걸 최적화하려 하지 말고 트래픽이 많은 페이지, 무거운 라이브러리,  
또는 초기 로딩이 느린 화면부터 점진적으로 적용하면 좋습니다.
다음 글에서는 코드 스플리팅 이후 단계인 **번들 분석과 최적화 과정**을 함께 살펴보겠습니다.