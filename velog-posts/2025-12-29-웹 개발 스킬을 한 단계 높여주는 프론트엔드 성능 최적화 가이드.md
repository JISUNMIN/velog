<p><img alt="" src="https://velog.velcdn.com/images/sunmins/post/8cbc37c7-bde2-4318-a048-6d0d829a3527/image.jpg" /></p>
<p>유동균 지음</p>
<p>⭐️ <strong>4 / 5</strong></p>
<hr />
<h2 id="리뷰">리뷰</h2>
<p>요즘 웹 성능 최적화에 대해 관심이 생겼다.<br />점점 단순히 기능을 구현하는 것에서 끝나는 게 아니라,<br />사용자 경험(UX)을 함께 고민하게 되는 단계로 넘어가고 있는 것 같다.</p>
<p>웹 성능을 높이는 이유는 단순하다.<br />빠르고 사용하기 편한 서비스일수록 유저가 유입되고,<br />그 결과 더 많은 사용과 수익으로 이어지기 때문이다.</p>
<p>나 역시 느리거나 버벅거리는 서비스는<br />잘 사용하지 않게 된다.<br />특히 국가기관에서 만든 웹 서비스들을 보면<br />“어쩔 수 없이 써야 하니까 이렇게 만든 건가?”<br />라는 생각이 들 정도로 성능이 아쉬운 경우도 많다.</p>
<p>이 책은  <strong>프론트엔드 관점에서 웹 성능을 어떻게 개선할 수 있는지</strong>를  
비교적 쉽게 설명해 주는 책이다.</p>
<hr />
<h2 id="성능-최적화의-두-가지-큰-축">성능 최적화의 두 가지 큰 축</h2>
<p>책에서는 성능 최적화를 크게 <strong>로딩 최적화</strong>와 <strong>렌더링 최적화</strong>로 나누어 설명한다.</p>
<h3 id="1-로딩-최적화">1. 로딩 최적화</h3>
<p>로딩 최적화는<br />초기에 불러오는 리소스(특히 JS 번들)의 용량과 로딩 방식에 영향을 받는다.</p>
<ul>
<li>번들이 클수록 → 초기 로딩 속도 저하</li>
</ul>
<p>이를 개선하기 위한 방법으로<br /><strong>코드 스플리팅을 통해 번들을 분리하고</strong>,  
그 이후 로딩 전략으로 다음과 같은 기법들이 소개된다.</p>
<ul>
<li>지연 로딩(Lazy Loading)</li>
<li>사전 로딩(Preloading, Prefetching)</li>
</ul>
<p>또한 텍스트 최적화, 이미지 최적화 같은 기법도 함께 다루며,<br />Chrome DevTools의 <strong>Network 탭</strong>을 활용해<br />실제 네트워크 요청과 리소스 크기를 분석하는 방법도 설명한다.</p>
<hr />
<h3 id="2-렌더링-최적화">2. 렌더링 최적화</h3>
<p>렌더링 최적화는<br />리소스를 모두 받아온 이후<br />HTML, CSS, JS가 실제 화면에 그려지는 과정을 최적화하는 것이다.</p>
<p>이를 위해서는 다음에 대한 이해가 중요하다고 한다.</p>
<ul>
<li>브라우저의 렌더링 과정</li>
<li>사용하는 프레임워크(예: React)의 라이프사이클</li>
</ul>
<p>렌더링 최적화 기법으로는 다음과 같은 방법들이 소개된다.</p>
<ul>
<li>병목 코드 최적화</li>
<li>불필요한 렌더링 방지</li>
<li>애니메이션 최적화</li>
<li>메모이제이션(useMemo, useCallback 등)</li>
</ul>
<p>React를 사용하는 경우<br /><strong>React DevTools</strong>를 통해 실제 렌더링 비용을 확인할 수 있다.</p>
<hr />
<p>또한 구글에서 개발한 <strong>Lighthouse</strong>는  
위에서 설명한 로딩과 렌더링을 포함해<br /><strong>성능 전반(로딩 + 렌더링 + 접근성 + SEO 등)</strong>을  
종합적으로 점검해 주는 도구이다.
책을 통해 그동안 막연하게만 알고 있던 LCP, TTI, TBT, CLS 등의 성능 지표가 무엇을 의미하는지를 알 수 있었다.</p>
<hr />
<h2 id="성능-최적화를-위한-다양한-도구들">성능 최적화를 위한 다양한 도구들</h2>
<p>책에서는 실무에서 바로 활용할 수 있는 도구들도 다양하게 소개한다.</p>
<ul>
<li><strong>Squoosh</strong>: 이미지 압축 도구</li>
<li><strong>PurgeCSS</strong>: 사용하지 않는 CSS 제거</li>
<li><strong>Media.io</strong>: 동영상 압축</li>
<li><strong>Transfonter</strong>: 웹 폰트 변환 도구</li>
</ul>
<p>이러한 도구를 활용하면<br />이미지, 동영상, 폰트 등의 용량을 크게 줄일 수 있지만,<br />최신 포맷(WebP, AVIF 등)은<br />브라우저 호환성 문제가 있다는 단점도 함께 언급한다.</p>
<p>이를 보완하기 위한 방법으로는 다음이 소개된다.</p>
<ul>
<li><code>&lt;picture&gt;</code> 태그</li>
<li><code>&lt;video&gt;</code> 태그의 fallback 설정</li>
</ul>
<p>이를 통해<br />지원하지 않는 브라우저에서는 기존 포맷을 제공하는 방식도 알게 되었다.</p>
<hr />
<h2 id="✍️-기억에-남은-배운-점">✍️ 기억에 남은 배운 점</h2>
<p>책에서는 브라우저 렌더링 과정을 다음과 같이 설명한다.
DOM, CSSOM 생성
→ 렌더 트리 생성
→ 레이아웃(Layout)
→ 페인트(Paint)
→ 컴포지트(Composite)</p>
<p>여기서 <strong>리플로우(Reflow)</strong>와 <strong>리페인트(Repaint)</strong> 개념이 등장한다.</p>
<ul>
<li><strong>리플로우</strong>: 레이아웃 단계부터 다시 실행</li>
<li><strong>리페인트</strong>: 레이아웃은 건너뛰고 페인트부터 실행</li>
</ul>
<p>렌더링 이후 JS로 인해 CSS가 변경되면<br />이 과정이 다시 발생하게 되고,<br />이는 CPU 자원을 많이 사용하는 작업이 된다.</p>
<p>이때 <code>transform</code>, <code>opacity</code> 같은 CSS 속성은<br />레이아웃과 페인트를 건너뛰고<br />GPU를 활용한 컴포지트 단계에서만 처리되기 때문에<br />성능상 유리하다는 점을 알게되었다.</p>
<p>그동안 애니메이션에서<br />왜 <code>transform</code>, <code>opacity</code>를 자주 쓰나 했는데,<br />성능과도 밀접하게 관련되어 있다는 점을 알게 되었다.</p>
<hr />
<p>또한 폰트 로딩 방식과 관련해 
FOUT와 FOIT이라는 용어도 새롭게 알게 되었다.</p>
<p>그동안 폰트가 로딩되는 과정을 유심하게 관찰해 본 적은 거의 없었는데, <strong>FOUT</strong>는 기본 폰트로 텍스트를 먼저 보여준 뒤
커스텀 폰트가 로딩되면 이를 교체하는 방식이고, 
<strong>FOIT</strong>은 폰트가 로딩될 때까지 텍스트를 아예 보여주지 않다가
웹폰트가 적용되는 방식이라는 점을 알게 되었다.</p>
<p>이론적으로는 디자인의 일관성이 중요한 경우 FOIT를 선택할 수도 있지만,
실제로는 사용자 경험을 더 중요하게 고려해
텍스트를 바로 보여주는 FOUT 방식을 더 많이 사용한다고 한다.</p>
<p>또한 이러한 폰트 로딩 동작을
<code>@font-face</code>의 <code>font-display</code> 속성을 통해
개발자가 직접 제어할 수 있다는것도 배웠다.</p>
<hr />
<h2 id="총평">총평</h2>
<p>전반적으로 이 책은<br /><strong>프론트엔드 성능 최적화 기법을 꽤 체계적으로 정리해 준다</strong>는 인상을 받았다.</p>
<p>단순히 “이런 기법이 있다”에서 끝나는 것이 아니라,</p>
<ul>
<li>왜 필요한지</li>
<li>적용하면 무엇이 개선되는지</li>
</ul>
<p>를 함께 설명해 주어서 이해하기 쉬웠다.</p>
<p>당장 모든 내용을 완벽하게 적용할 수는 없겠지만,<br />나중에 프로젝트를 개선할 때<br />하나씩 적용해 보고 싶은 내용들이 많았다.</p>
<p>웹 성능에 관심이 생기기 시작한 프론트엔드 개발자라면<br />한 번쯤 읽어볼 만한 좋은 책이라고 생각한다.</p>