여러 프로젝트 목록 중에서 사용자가 선택한 프로젝트 항목에 **포커스(Focus)**를 주고, 해당 항목이 보이도록 **스크롤(Scroll)**을 자동으로 이동시키는 방법과 키보드 접근성에 대해 정리해보겠습니다.

---

## 📝 사용 목적

- **사용자가 선택한 프로젝트 항목을 명확하게 표시**하기 위해 포커스와 스크롤 기능을 적용했습니다.
- 프로젝트 리스트가 길어졌을 경우, 선택된 항목이 **스크롤 영역 밖에 있어도 자동으로 보이게** 처리합니다.
- 페이지 진입 시 또는 프로젝트 선택이 변경되었을 때 **선택된 항목으로 포커스 자동 이동**이 필요했습니다.
- **키보드 탐색(ArrowUp / ArrowDown / Enter / Space)** 을 지원하여 마우스 없이도 접근성과 사용성을 향상시켰습니다.

## 💡 주요 개념

| 개념                                  | 설명                                                                          |
|---------------------------------------|-------------------------------------------------------------------------------|
| `ref`                                 | DOM 요소에 직접 접근하기 위한 React 훅/속성                                   |
| `ref.current`                         | 현재 참조 중인 DOM 요소                                                       |
| `ref={(el) => (itemRefs.current[index] = el)}` | 각 프로젝트 항목 DOM을 배열에 저장, 포커스 및 스크롤 제어에 활용                  |
| `element.focus()`                     | 해당 요소로 키보드 포커스 이동 (DOM API)                                                |
| `element.scrollIntoView()`           | 해당 요소가 스크롤 영역 내 보이도록 스크롤 이동 (DOM API)                                  |
| `onKeyDown` 핸들러                    | 키보드 이벤트를 직접 처리 (화살표 키, Enter, Space 등)                         |
| HTML 태그 역할                         | `button`, `a` 태그는 기본적으로 Enter, Space키 동작 지원                       |

- **useRef와 ref**
  - React의 `useRef` 훅과 `ref` 속성을 사용하여 각 항목의 **DOM 요소를 직접 참조**할 수 있습니다.
  - 포커스나 스크롤을 주려면 **조작 대상인 DOM 요소에 접근하는 것이 필수**입니다.

- **focus() 와 scrollIntoView() 메서드**
  - 이들은 **브라우저의 DOM API**로서, 실제로 **포커스 이동과 스크롤 동작을 수행**합니다.
  - `focus()`는 키보드 포커스를 해당 요소로 이동시키고,  
    `scrollIntoView()`는 요소가 화면에 보이도록 스크롤을 자동으로 조절합니다.
    
> **`useRef`로 DOM 요소를 참조하고, DOM API (`focus()`, `scrollIntoView()`)로 실제 조작을 합니다.**


## ⌨️ 키보드 Enter, Space 자동 클릭 지원 태그와 접근성

| 태그/요소          | Enter 키 동작 자동 지원 | Space 키 동작 자동 지원 | Tab 포커스 가능 | 비고                                      |
|-------------------|-----------------------|-----------------------|---------------|------------------------------------------|
| `<button>`        | 예                    | 예                    | 예            | 키보드 접근성 최적화, 자동 클릭 이벤트 발생 |
| `<a href="...">`  | 예 (링크 이동)          | 아니요                 | 예            | `href` 없으면 자동 클릭 안 됨             |
| `<a>` (href 없음) | 아니요                 | 아니요                 | 아니요 (직접 설정 필요) | `role`, `tabIndex`, `onKeyDown` 구현 필요  |
| 기타 요소 (`div`) | 아니요                 | 아니요                 | 아니요 (직접 설정 필요) | 접근성 직접 구현 필요                        |


## 🔁 구현 코드

```tsx
"use client";

import React, { useEffect, useRef } from "react";

export function KanbanSidebar({ filteredProjects, selectedProjectId }) {
  // 버튼 ref 배열
  const itemRefs = useRef<(HTMLButtonElement | null)[]>([]);

  // 키보드 탐색 핸들러
  const handleKeyDown = (
    e: React.KeyboardEvent<HTMLButtonElement>,
    index: number
  ) => {
    if (e.key === "ArrowDown") {
      e.preventDefault();
      const nextIndex = (index + 1) % (filteredProjects?.length ?? 1);
      itemRefs.current[nextIndex]?.focus();
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      const prevIndex =
        (index - 1 + (filteredProjects?.length ?? 1)) %
        (filteredProjects?.length ?? 1);
      itemRefs.current[prevIndex]?.focus();
    }
  };

  useEffect(() => {
    if (!filteredProjects || !selectedProjectId) return;

    const selectedIndex = filteredProjects.findIndex(
      (p) => String(p.id) === selectedProjectId
    );

    if (selectedIndex !== -1) {
      const element = itemRefs.current[selectedIndex];
      if (element) {
        // 1) 포커스 이동 (스크롤 방지)
        element.focus({ preventScroll: true });
        // 2) 부드러운 스크롤 이동
        element.scrollIntoView({
          behavior: "smooth",
          block: "nearest",
        });
      }
    }
  }, [filteredProjects, selectedProjectId]);

  return (
    <div>
      {filteredProjects?.map((project, index) => (
        <button
          key={project.id}
          onKeyDown={(e) => handleKeyDown(e, index)}
          ref={(el) => {
            itemRefs.current[index] = el 
          }}
          tabIndex={0}
        >
          {project.projectName}
        </button>
      ))}
    </div>
  );
}


```

## 📌 구현 설명

### button 태그 사용 이유  
**button은 키보드에서 Enter, Space 키로 기본 클릭 동작이 자동으로 지원**되기 때문에, onKeyDown에서 Enter 키 처리를 따로 구현하지 않고도 쉽게 구현하기 위해 사용했습니다.

### itemRefs 배열  
각 프로젝트 버튼의** DOM 참조를 `useRef`로 배열 형태로 저장해 포커스 이동 시 사용**합니다.

### 선택된 항목 포커스 이동  
`useEffect`에서 URL 파라미터 등으로 받은 **`selectedProjectId`에 맞는 인덱스를 찾아, 해당 버튼에 `focus({ preventScroll: true })`를 호출해 키보드 포커스를 이동**시킵니다.

### 부드러운 스크롤 이동  
**`scrollIntoView({ behavior: "smooth", block: "nearest" })`를 사용해 현재 뷰포트 내에서 자연스럽게 스크롤 위치를 조정**했습니다.

---


## ✅ 결론
키보드 접근성 확보를 위해서는 `<button>, <a href="...">`를 최대한 활용하는 것이 좋습니다.

디자인 또는 구조상 div를 사용한다면 반드시 tabIndex, role, 키보드 이벤트 핸들러를 구현해 접근성을 보완해야 합니다.

React에서 ref를 이용해 DOM 요소에 직접 접근하여, 사용자가 선택한 항목에 포커스와 스크롤을 자동으로 부여할 수 있습니다.

handleKeyDown 이벤트 핸들러로 화살표키 탐색과 Enter/Space 선택 기능을 구현하여 사용성 및 접근성을 향상시킬 수 있습니다.
