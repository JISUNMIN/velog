<p>개발 도중 <strong>다크 모드로 설정한 뒤 새로고침하면 잠깐 라이트 모드로 보였다가 다시 다크 모드로 바뀌는 현상</strong>이 발생했습니다.</p>
<p>이 글에서는 해당 문제가 발생한 <strong>원인</strong>, 그리고<br /><strong>SSR 환경에서 안전하게 theme 상태를 초기화하는 방법</strong>을 정리합니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/sunmins/post/cbdaa0b7-5eab-4280-bbad-632641641bc8/image.gif" /></p>
<hr />
<h2 id="문제-현상">문제 현상</h2>
<h3 id="재현-경로">재현 경로</h3>
<ol>
<li>Theme를 <strong>dark mode</strong>로 변경</li>
<li>페이지 새로고침</li>
<li><strong>초기에는 light 모드로 렌더링</strong></li>
<li>잠시 후 dark 모드로 전환됨 (깜빡임 발생)</li>
</ol>
<p>즉, <strong>저장된 theme 값이 있음에도 불구하고 초기 렌더링에서는 반영되지 않는 문제</strong>였습니다.</p>
<hr />
<h2 id="기존-코드">기존 코드</h2>
<h3 id="1-rootlayout-ssr">1. RootLayout (SSR)</h3>
<pre><code class="language-tsx">export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    &lt;QueryProvider&gt;
      &lt;UserStoreInitializer /&gt;
      &lt;html lang=&quot;en&quot;&gt;
        &lt;ThemeProviderLayout
          geistSans={geistSans.variable}
          geistMono={geistMono.variable}
        &gt;
          {children}
          &lt;Toast /&gt;
        &lt;/ThemeProviderLayout&gt;
      &lt;/html&gt;
    &lt;/QueryProvider&gt;
  );
}</code></pre>
<h3 id="2-theme-상태-관리-zustand--persist">2. Theme 상태 관리 (Zustand + persist)</h3>
<pre><code class="language-ts">
// src/app/store/useThemeStore.ts
import { create } from &quot;zustand&quot;;
import { persist } from &quot;zustand/middleware&quot;;

export type Theme = &quot;light&quot; | &quot;dark&quot; | undefined;

interface ThemeState {
  theme: Theme;
  toggleTheme: () =&gt; void;
  setTheme: (theme: Theme) =&gt; void;
}

export const useThemeStore = create&lt;ThemeState&gt;()(
  persist(
    (set) =&gt; ({
      theme: &quot;dark&quot;,
      toggleTheme: () =&gt;
        set((state) =&gt; ({
          theme: state.theme === &quot;light&quot; ? &quot;dark&quot; : &quot;light&quot;,
        })),
      setTheme: (theme) =&gt; set({ theme }),
    }),
    {
      name: &quot;theme-storage&quot;,
    },
  ),
);
</code></pre>
<h3 id="3-themeproviderlayout-client-component">3. ThemeProviderLayout (Client Component)</h3>
<pre><code class="language-tsx">&quot;use client&quot;;

import { useThemeStore } from &quot;@/store/useThemeStore&quot;;

export default function ThemeProviderLayout({
  children,
  geistSans,
  geistMono,
}: Props) {
  const { theme } = useThemeStore();

  return (
    &lt;body className={`${geistSans} ${geistMono} antialiased ${theme}`}&gt;
      {children}
    &lt;/body&gt;
  );
}
</code></pre>
<hr />
<h2 id="원인-분석">원인 분석</h2>
<p>SSR 시점에 HTML이 먼저 생성되고,
Zustand(persist)가 localStorage에서 상태를 복원(hydration)하는 시점은 그 이후이기 때문</p>
<h3 id="순서">순서</h3>
<ol>
<li><p>서버 렌더링(SSR)
<code>&lt;html&gt;</code>에 theme 관련 클래스 없음
<code>global.css</code> 기준 기본 theme(light)가 적용된 HTML 생성</p>
</li>
<li><p>브라우저 로딩
zustand가 <code>localStorage</code>에서 theme 값을 읽음
<code>dark</code>로 상태 변경
DOM class 변경 -&gt; dark모드 적용</p>
</li>
</ol>
<p>이 과정에서 HTML/CSS는 이미 light 기준으로 그려진 뒤
<strong>클라이언트 상태가 적용되면서 화면이 한번 더 바뀌는 현상이 발생</strong></p>
<p>-&gt; SSR에서 초기 theme를 결정할 수 있는 수단이 필요</p>
<hr />
<h2 id="해결">해결</h2>
<p>SSR 단계에서는 Cookie를 기준으로 theme를 결정하고
CSR 이후에는 기존 Zustand 로직을 그대로 유지</p>
<blockquote>
<p>Zustand를 유지한 이유? </p>
</blockquote>
<ul>
<li>Zustand는 전역에서 참조·변경이 쉽고,  </li>
<li>React 상태처럼 변경 시 자동으로 리렌더링되기 때문에  </li>
<li>theme 변경에 따른 UI 동기화가 간단함</li>
<li>CRS 이후의 상태 관리 편의성, 유지보수성을 확보할 수 있기 때문에 유지 하였음.</li>
</ul>
<p>SSR: Cookie -&gt; <code>&lt;html class=&quot;dark&quot;&gt;</code>
CSR: zustand 상태 관리
Zustand 변경 시 cookie도 함께 갱신 </p>
<hr />
<h2 id="수정-후-코드">수정 후 코드</h2>
<h3 id="1-rootlayout-ssr-1">1. RootLayout (SSR)</h3>
<p>SSR에서 Cookie 기반 초기 Theme 결정</p>
<pre><code class="language-tsx">import { cookies } from &quot;next/headers&quot;;
import type { Theme } from &quot;@/store/useThemeStore&quot;;

async function getInitialTheme() {
  const cookieStore = await cookies();
  const cookieTheme = cookieStore.get(&quot;theme&quot;)?.value as Theme;
  return cookieTheme ?? &quot;dark&quot;;
}

export default async function RootLayout({
  children,
}: Readonly&lt;{
  children: React.ReactNode;
}&gt;) {
  const initialTheme = await getInitialTheme();

  return (
    &lt;QueryProvider&gt;
      &lt;UserStoreInitializer /&gt;
      &lt;html lang=&quot;en&quot; className={initialTheme}&gt;
        &lt;ThemeProviderLayout geistSans={geistSans.variable} geistMono={geistMono.variable}&gt;
          {children}
          &lt;Toast /&gt;
        &lt;/ThemeProviderLayout&gt;
      &lt;/html&gt;
    &lt;/QueryProvider&gt;
  );
}</code></pre>
<h3 id="2-themeproviderlayout-client-component">2. ThemeProviderLayout (Client Component)</h3>
<p>Client에서 Zustand ↔ Cookie 동기화</p>
<pre><code class="language-tsx">&quot;use client&quot;;

import { useThemeStore } from &quot;@/store/useThemeStore&quot;;
import { useEffect } from &quot;react&quot;;

export default function ThemeProviderLayout({
  children,
  geistSans,
  geistMono,
}: Props) {
  const { theme } = useThemeStore();

  useEffect(() =&gt; {
    if (!theme) return;

    const root = document.documentElement;
    root.classList.remove(&quot;dark&quot;, &quot;light&quot;);
    root.classList.add(theme);

    // Cookie 갱신 (1년 유지)
    document.cookie = `theme=${theme}; path=/; max-age=31536000`;
  }, [theme]);

  return (
    &lt;body className={`${geistSans} ${geistMono} antialiased`}&gt;
      {children}
    &lt;/body&gt;
  );
}
</code></pre>
<blockquote>
<p><code>path=/</code>란?
쿠키가 <strong>사이트 전체에서 전송되도록 설정</strong>하는 옵션이다.</p>
</blockquote>
<ul>
<li>쿠키는 설정된 <code>path</code> 이하의 URL에서만 유효하다.</li>
<li>대부분의 전역 설정(theme, locale 등)은 모든 페이지에서 필요하므로 <code>path=/</code>를 사용한다.</li>
<li>특정 페이지나 경로에서만 쿠키를 사용하고 싶다면<br /><code>path=/dashboard</code>처럼 설정해 해당 경로 하위에서만 쿠키가 보이도록 제한할 수 있다.</li>
</ul>
<hr />
<p><img alt="" src="https://velog.velcdn.com/images/sunmins/post/54ea48cc-cd28-49f9-b187-f4607f125d5e/image.gif" /></p>
<h2 id="구조-정리">구조 정리</h2>
<pre><code class="language-text">요청 발생
  ↓
SSR: Cookie 기반으로 &lt;html className=&quot;theme&quot;&gt; 생성
  ↓
브라우저 렌더링
  ↓
CSR: Zustand hydrate
  ↓
Zustand 변경 시 Cookie도 동기화</code></pre>
<h2 id="정리">정리</h2>
<ul>
<li><p><code>&lt;html&gt;</code>을 포함하는 RootLayout은 기본적으로 SSR로 렌더링됩니다.</p>
</li>
<li><p>이렇게 해야</p>
<ul>
<li>초기 HTML이 바로 내려오고<ul>
<li>CSS가 즉시 적용되며</li>
<li>초기 렌더링 속도(FCP/LCP)와 SEO 이점을 얻을 수 있습니다.</li>
</ul>
</li>
</ul>
</li>
<li><p>문제는 theme 상태처럼</p>
<ul>
<li>클라이언트(localStorage, Zustand persist)에만 존재하는 값을</li>
<li>SSR 단계에서 알 수 없다는 점입니다.</li>
</ul>
</li>
<li><p>이 상태로 SSR을 유지하면,</p>
<ul>
<li>서버는 기본 theme로 HTML을 만들고</li>
<li>클라이언트에서 실제 theme를 읽어 다시 렌더링하면서</li>
<li>불필요한 UI 변경(깜빡임) 이 발생하게 됩니다.</li>
</ul>
</li>
</ul>
<h2 id="결론">결론</h2>
<ul>
<li>Next.js + SSR 환경에서
localStorage 기반 상태(Zustand persist)는 초기 렌더링 기준으로 부적합합니다.</li>
<li>Theme처럼 초기 HTML/CSS에 영향을 주는 값은 반드시 SSR에서 결정이 필요합니다.</li>
<li>cookie를 추가하여 해결 하였습니다.</li>
</ul>