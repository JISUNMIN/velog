개발 중 `as const`를 사용하다가 타입 에러가 발생했습니다.  
`as const`를 대략적으로만 알고 있었는데, 이번 일을 계기로 자세히 알아보게 되었습니다.  
이번 글에서는 에러가 발생한 이유와 해결 과정을 정리했습니다.

---

## 💥 문제 상황

다음과 같이 상수 배열을 선언하고 상태 초기값에 사용했습니다.

```ts
const DEFAULT_FILTER = ["GS_FS", "GS_CSB", "GS_SS"] as const;
const ALL_VALUE = "ALL" as const;

const [clickedFilter, setClickedFilter] =
  useState<string[]>([...DEFAULT_FILTER, ALL_VALUE]);
```

이때 타입스크립트가 다음과 같은 에러를 출력했습니다.

```
Type 'readonly ["GS_FS", "GS_CSB", "GS_SS", "ALL"]' is not assignable to type 'string[]'.
The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.
```

`as const`가 붙은 값들이 **읽기 전용(readonly)** 으로 처리되어,  
가변 배열(`string[]`)을 기대하는 `useState<string[]>`에 바로 넣을 수 없다고 경고했습니다.

---

## 🔎 원인: [as const](https://velog.io/@sunmins/%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC-%EC%B0%B8%EC%A1%B0%EA%B0%92-%EB%B3%B5%EC%82%AC%EC%99%80-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%98-%EC%B0%A8%EC%9D%B4) 는 배열을 **읽기 전용(readonly)** 으로 만듭니다

`as const`를 붙이면 값이 **리터럴 타입**으로 고정되고,  
배열과 객체는 **readonly** 속성을 갖게 됩니다.

```ts
const DEFAULT_FILTER = ["GS_FS", "GS_CSB", "GS_SS"] as const;
// 타입: readonly ["GS_FS", "GS_CSB", "GS_SS"]

const ALL_VALUE = "ALL" as const;
// 타입: "ALL"
```

### 🤔 왜 문자열은 `readonly`가 아닐까?

`as const`는 값을 **불변(immutable)** 하게 고정하지만,  
`readonly`는 **참조형(객체, 배열)** 의 **참조나 프로퍼티 수정**을 막는 개념입니다.

- **원시값 (`string`, `number`, `boolean`)**
  - 값 자체가 이미 불변(immutable)이라 `readonly`가 붙을 필요가 없음.

- **객체 (`{}`), 배열 (`[]`)**
  - 내부 값이 바뀔 수 있기 때문에  
    `as const`를 사용하면 자동으로 `readonly`가 붙음.

`readonly`는 “값을 바꾸지 말라”가 아니라  
 “참조된 **프로퍼티나 구조를 바꾸지 말라**”는 뜻입니다.  

 그래서 **원시값에는 적용되지 않고**,  
 **객체나 배열에는 자동으로 붙습니다.**.

---

## 🙅 잘못된 임시 해결: 강제 캐스팅

```ts
defaultFilter: DEFAULT_FILTER as unknown as string[];
```

이 방식은 에러를 없애지만,  
타입 안전성이 완전히 깨지게 됩니다.  
자동완성과 오타 검증이 불가능하므로 사용하지 않는 것이 좋습니다.

---

## ✅ 해결 방법

### 1️⃣ 복사해서 가변 배열로 만들기

`as const`는 유지하되, 사용할 때만 **새 배열로 복사**했습니다.

```ts
// 스프레드 연산자
const init = [...DEFAULT_FILTER, ALL_VALUE]; // 타입: string[]

// 또는 Array.from()
const init = Array.from(DEFAULT_FILTER).concat(ALL_VALUE); // 타입: string[]
```

이렇게 하면 원본 상수는 그대로 readonly 상태로 유지되고,  
필요한 곳에서는 가변 배열로 안전하게 사용할 수 있습니다.

---

### 2️⃣ 상태 타입을 리터럴 유니온으로 관리

리터럴 타입의 이점을 살리기 위해 상태 타입을 명시적으로 지정했습니다.

```ts
const DEFAULT_FILTER = ["GS_FS", "GS_CSB", "GS_SS"] as const;
const ALL_VALUE = "ALL" as const;

type Filter = typeof DEFAULT_FILTER[number] | typeof ALL_VALUE;

const [clickedFilter, setClickedFilter] = useState<Filter[]>([
  ...DEFAULT_FILTER,
  ALL_VALUE,
]);
```

이 방식은 허용된 값만 상태에 들어가도록 강제해 주었습니다.

---

## 📘 보충 설명

### 🔹 리터럴 타입이란?

리터럴 타입은 **값 그 자체를 타입으로 사용하는 것**을 말합니다.  
예를 들어 아래 코드를 보면,

```ts
let status: "ON" = "ON";
```

`status`는 오직 `"ON"`만 가질 수 있습니다.  
즉, `"ON"`이라는 **값이 타입으로 고정**된 것입니다.

---

### 🔹 유니온(Union) 타입이란?

유니온 타입은 여러 타입 중 **하나라도 될 수 있다**는 의미입니다.

```ts
let state: "ON" | "OFF" | "PENDING";
```

이 변수는 `"ON"`, `"OFF"`, `"PENDING"` 중 하나만 가질 수 있습니다.

---

### 🔹 리터럴 유니온이란?

리터럴 타입과 유니온을 결합한 것으로,  
**“특정 값들 중 하나만 가능하다”** 를 표현합니다.

```ts
type Filter = "GS_FS" | "GS_CSB" | "GS_SS" | "ALL";
```

이 타입은 네 가지 문자열 중 하나만 허용되며,  
잘못된 값이 들어가면 컴파일 단계에서 에러를 냅니다.  
👉 즉, **enum처럼 동작하지만 더 간단한 표현 방식**입니다.

---

### 🔹 `typeof DEFAULT_FILTER[number]`는 왜 `number`가 들어가는가?

```ts
typeof DEFAULT_FILTER // → readonly ["GS_FS", "GS_CSB", "GS_SS"]
```

배열의 요소 타입을 꺼내려면 인덱스 접근 타입을 사용해야 합니다.

- `typeof DEFAULT_FILTER[0]` → `"GS_FS"`
- `typeof DEFAULT_FILTER[1]` → `"GS_CSB"`
- `typeof DEFAULT_FILTER[2]` → `"GS_SS"`

그런데, 모든 인덱스(0, 1, 2, …)의 타입을 한 번에 가져오려면  
**배열의 인덱스 타입인 `number`를 넣어야 합니다.**

즉,

```ts
typeof DEFAULT_FILTER[number]
```

은 `"GS_FS" | "GS_CSB" | "GS_SS"`라는 **요소 타입의 유니온**이 됩니다.

---

## 📚 `Array.from()`과 스프레드(`...`)의 차이

| 항목 | 스프레드(`[...]`) | `Array.from()` |
|------|--------------------|----------------|
| 목적 | 이터러블을 펼쳐 새 배열 생성 | 이터러블/배열-유사 객체를 배열로 변환 |
| 복사 + 변환(map) | 불가 (별도 `map` 필요) | 가능 (`Array.from(arr, fn)`) |
| 가독성 | 짧고 직관적 | 변환 로직이 있을 때 유용 |
| readonly → mutable | ✅ 해제됨 | ✅ 해제됨 |

단순 복사/병합에서는 스프레드를,  
변환이 필요하거나 **배열-유사 객체(array-like object)** 를 다룰 때는 `Array.from()`을 사용했습니다.

---

### 🔹 배열-유사 객체란?

배열처럼 `length` 속성과 인덱스를 가지고 있지만  
**진짜 배열은 아닌 객체**를 말합니다.

예를 들어:

```ts
function example() {
  console.log(arguments); // [Arguments] { 0: "a", 1: "b", length: 2 }
}
```

`arguments`는 배열처럼 생겼지만, 실제로는 `Array` 메서드(`map`, `filter` 등`)를 직접 쓸 수 없습니다.  
이런 것을 **배열-유사 객체(array-like object)** 라고 합니다.

그래서 `Array.from(arguments)`처럼 변환해야  
진짜 배열 메서드를 쓸 수 있습니다.

---

## 🧭 정리

- `as const`는 **리터럴 타입 고정 + readonly 속성 부여**를 수행했습니다.  
- 이로 인해 `string[]`이 필요한 곳에서 **타입 불일치 에러**가 발생했습니다.  
- 임시로 강제 캐스팅을 시도했지만 타입 안전성을 해쳤기 때문에 사용하지 않았습니다.  
- **스프레드(`...`)/`Array.from()`으로 새 배열을 만들어** 가변 배열을 전달하는 방식으로 해결했습니다.  
- `typeof DEFAULT_FILTER[number]` 문법을 통해 **배열 요소들의 리터럴 유니온 타입**을 얻을 수 있었습니다.  
- `Array.from()`은 **배열-유사 객체를 배열로 변환할 때** 유용합니다.  
- 이번 일을 통해 `as const`, `readonly`, `리터럴 유니온`, `Array.from()`의 작동 원리를 더 깊이 이해했습니다.

---
