이번 글에서는  
웹 개발을 하면서 **가장 자주 보지만 헷갈리기 쉬운 `window.addEventListener`와 이벤트 리스너**를 예시 중심으로 정리해보았습니다.

- **내장 이벤트와 커스텀 이벤트는 무엇이 다를까?**  
- **`useEffect`의 cleanup에서 왜 꼭 `removeEventListener`를 해야 할까?**  
- **왜 웹에서는 커스텀 이벤트를 잘 안 쓰는데, 앱(React Native)에서는 자주 쓸까?**  
---

## 1. `window.addEventListener`란?

- **`window.addEventListener`**
  - 브라우저가 제공하는 **Web API** 중 하나입니다.
  - `window`, `document`, DOM 요소 등에 **이벤트 리스너를 등록**할 때 사용합니다.
  - “이런 이벤트가 발생하면, 이 콜백 함수를 실행해주세요”라는 의미입니다.

```js
window.addEventListener("scroll", handleScroll);
```

위 코드는 다음과 같은 뜻을 가집니다.

> “브라우저가 `scroll` 이벤트를 발생시키면, `handleScroll`을 실행해주세요.”

즉, 이벤트의 **정확한 발생 시점은 내가 제어할 수 없고**,  
**“발생했을 때 알려달라”**고 브라우저에 미리 등록해두는 구조입니다.

### ✔ addEventListener vs 이벤트 리스너(listener)

- `addEventListener` → 이벤트 리스너를 “등록하는 함수(행위)”
- `이벤트 리스너(listener)` → 이벤트 발생 시 실행될 “콜백 함수(대상)”

즉, **이벤트 리스너는 이벤트가 발생할 때 실행될 ‘콜백 함수’이고,
addEventListener는 그 리스너를 등록하는 함수**입니다.

---

## 2. 내장 이벤트(Built-in Event)란?

내장 이벤트는 **브라우저가 스스로 발생시키는 이벤트**입니다.  
DOM 요소나 `window`·`document` 수준에서 자동으로 발생합니다.

### ✔ 대표적인 내장 이벤트들

| 이벤트명              | 대상            | 설명                               | 예시 사용처                          |
|----------------------|-----------------|------------------------------------|--------------------------------------|
| `scroll`             | window, element | 스크롤이 발생했을 때               | 무한스크롤, Top 버튼 표시      |
| `resize`             | window          | 창 크기가 변경되었을 때            | 반응형 레이아웃 처리               |
| `keydown`, `keyup`   | window, element | 키보드 입력                        | 단축키 기능, 게임 입력 처리                |
| `click`              | element         | 요소 클릭                          | 버튼 클릭 처리                       |
| `input`, `change`    | input 등        | 입력 값 변경                       | 폼 입력 검증                         |
| `visibilitychange`   | document        | 탭 전환(보임/숨김)                  | 백그라운드 시 타이머 일시정지          |
| `online`, `offline`  | window          | 네트워크 연결/끊김                 | 오프라인 안내 배너 표시               |

이들은 모두 브라우저가 **스스로 이벤트를 발생**시키기 때문에
반드시 이벤트 리스너로 처리해야 합니다.

---

## 3. 커스텀 이벤트(Custom Event)란?

커스텀 이벤트는 **브라우저가 아니라 개발자가 직접 만들어서 발생시키는 이벤트**입니다.

### ✔ 기본 커스텀 이벤트 예시

```js
// 1. 이벤트 리스너 등록
function onRefresh() {
  console.log("refresh 이벤트 감지");
}
window.addEventListener("refresh", onRefresh);

// 2. 이벤트 발생(emit)
window.dispatchEvent(new Event("refresh"));
```

위 예시는 **브라우저 환경(웹)**에서 사용하는 방식입니다.
브라우저에는 window 객체가 존재하므로, 이 객체에 이벤트를 등록하고(addEventListener),
직접 발생시키기(dispatchEvent)가 가능합니다.

---

## 4. 웹에서는 커스텀 이벤트가 왜 잘 안 쓰일까?

일반적인 React 웹 개발에서는 대부분의 UI 통신이
아래 방식으로 해결됩니다.

- 부모 → 자식:** props**
- 자식 → 부모: **콜백 함수(props callback)**
- 여러 곳에서 공유되는 데이터: **Redux / Zustand / Context**

이 구조만으로도 대부분의 데이터 흐름을 충분히 처리할 수 있습니다.

따라서, 웹(Web)에서는 커스텀 이벤트를 일부러 사용할 필요가 적기 때문에
실제 코드에서 자주 보이지 않습니다.

커스텀 이벤트는 특정 구조적 제약이 있을 때(전역 알림 등)만 제한적으로 사용됩니다

---

## 5. cleanup에서 removeEventListener가 필요한 이유

React에서는 `addEventListener`를 보통 아래처럼 **useEffect 안에서 등록**합니다.

```js
useEffect(() => {
  function handleScroll() {
    console.log("스크롤!");
  }

  window.addEventListener("scroll", handleScroll);

  return () => {
    window.removeEventListener("scroll", handleScroll);
  };
}, []);
```
그럼 질문이 생깁니다.

>“왜 굳이 return에서 removeEventListener를 해줘야 할까?”
“컴포넌트가 언마운트되면 자동으로 사라지는 거 아닐까?”

아닙니다. 
`window.addEventListener`로 등록한 리스너는  
React가 아니라 **브라우저 전역(window)** 에 등록됩니다.

따라서 컴포넌트가 사라져도 삭제되지 않습니다.
그래서 **cleanup 함수**가 필요합니다.


### ✔ cleanup을 하지 않았을때 문제점
#### 1) 이벤트 리스너가 “중복 등록”됨

컴포넌트가 리렌더링되거나 다시 마운트되면
같은 리스너가 window에 여러 번 추가됩니다.

#### 2) 이벤트가 여러 번 실행되는 버그 발생

등록된 리스너가 3개면 클릭 시 3번 실행됩니다.

#### 3) 메모리 누수 발생

컴포넌트가 이미 사라졌는데도
리스너가 계속 살아있어 메모리가 회수되지 못합니다.

---

## 6. 함수 vs addListener vs window.addEventListener

어떤 것은 **변수에 넣을 수 있고**, 어떤 것은 **넣어도 소용이 없습니다.**  
그 차이를 정확하게 이해해야 이벤트 시스템을 제대로 사용할 수 있습니다.

### ✔ 1) 일반 함수(fn)는 “호출해야 실행된다”

```js
const fn = () => console.log("hello");
```

- fn(); // 직접 호출해야 실행됨
- 변수에 넣는다고 실행되지 않음
- 실행은 fn() 호출 시점에 일어남

### ✔ 2) EventEmitter의 addListener는 “호출 = 등록”

```js
const subscription = emitter.addListener("paymentSuccess", callback);
```
이 코드가 실행되면:

- `addListener()`가 호출됨
- emitter 내부의 리스너 목록에 callback이 즉시 등록됨
- 등록된 리스너를 제거할 수 있는 subscription 객체 반환

>addListener는 반환값을 변수에 넣었는지와 상관없이,
addListener(...) 라는 함수가 호출된 순간에 이미 등록이 완료됩니다.

### ✔3) window.addEventListener는 subscription을 반환하지 않는다

```js
const sub = window.addEventListener("scroll", handler);

console.log(sub); // undefined
```
- window.addEventListener는 반환값이 없다(undefined)
- DOM 이벤트 시스템은 EventEmitter 방식이 아님
- 삭제는 반드시 이렇게만 가능:
window.removeEventListener("scroll", handler);

반환값이 없기 때문에 “subscription.remove()” 같은 패턴을 사용할 수 없음

---

####  요약

- EventEmitter.addListener는 반환값(subscription)이 있기 때문에
변수로 받을 수 있고 → subscription.remove()로 해지 가능

- window.addEventListener는 반환값이 없기 때문에
변수에 넣어도 의미 없고 → 반드시 removeEventListener(handler)로 해지해야 한다.

---

## 7. 참고
### 7-1. 앱(React Native)에서는 커스텀 이벤트가 왜 자주 쓰일까?

React Native 환경은 웹과 다르게 **window / DOM이 없습니다.**  
또한 iOS/Android 네이티브 환경과 상호작용하며  
다양한 네이티브 이벤트가 발생합니다.

예: GPS 위치, BLE 데이터, 센서, 알림 등

웹에서는 `window.dispatchEvent()` 같은 Web API를 사용할 수 있지만,
React Native에는 `window` 자체가 없기 때문에 동일한 방식으로 커스텀 이벤트를 만들 수 없습니다.

대신 React Native에서는 **네이티브 → JS 사이의 이벤트 전달을 위해 EventEmitter 패턴을 사용합니다.**


```js
import EventEmitter from "eventemitter3";

const emitter = new EventEmitter();

// 1. 이벤트 리스너 등록
emitter.on("refresh", () => {
  console.log("refresh 이벤트 감지!");
});

// 2. 이벤트 발생
emitter.emit("refresh");

```

### 7.2 앱에서는 왜 emit이 더 자주 나올까?

웹에서는 대부분의 변화가 React 트리 안에서 발생하지만,
앱에서는 React 트리 밖에서(네이티브/OS에서) 변화가 발생합니다.

#### 🟢 웹에서 발생하는 변화 (React 내부에서 해결 가능)

- 버튼 클릭 → refetch()
- 라우트 변경 → useEffect로 감지
- 폼 제출 → mutation 후 invalidateQueries
- UI 내에서 값 변화 → 상태 변화로 자동 반영

→ props / state / React Query만으로 충분, 별도의 emit 필요 없음

---

#### 🔵 RN에서는 “React 바깥 세상”에서 이벤트가 자주 발생

예를 들어:

- Push 알림에서 “결제 완료됨” 신호 수신
- 네이티브 결제 SDK가 성공/실패 이벤트 발생
- PS가 백그라운드에서 위치 업데이트
- BLE(Bluetooth Low Energy) 센서가 주기적으로 데이터 전송
- 앱 포그라운드/백그라운드 전환 이벤트 발생

이런 건 모두 **JS 안이 아니라 OS/Native 모듈이 발생시키는 사건**입니다.

그래서 RN에서는

네이티브가 emit → JS가 addListener로 받고 → React Query로 데이터 refetch
라는 패턴이 자주 등장합니다.

```ts
// 네이티브에서 "paymentSuccess" 이벤트 emit
emitter.addListener("paymentSuccess", () => {
  queryClient.invalidateQueries(["payments"]);
});
```
- 서버 데이터 관리 → React Query
- 네이티브 이벤트 전달 → EventEmitter
- 둘을 분리하고 필요한 곳만 연결

---

## 💬 요약 정리

- 내장 이벤트는 브라우저가 자동으로 발생시키는 이벤트입니다.  
- 커스텀 이벤트는 직접 생성하여 간접 호출이 필요할 때 사용합니다.  
- React에서는 cleanup에서 반드시 `removeEventListener`를 수행해야 합니다.  
- 웹에서는 props/state/상태관리만으로 충분하기 때문에 커스텀 이벤트를 자주 쓰지 않습니다.
- React Native는 네이티브 세계(OS)에서 발생하는 이벤트가 많기 때문에
EventEmitter 기반의 이벤트 구독(addListener)이 자주 등장합니다.
- addEventListener/addListener는 호출되는 순간 “등록”이 끝납니다.

