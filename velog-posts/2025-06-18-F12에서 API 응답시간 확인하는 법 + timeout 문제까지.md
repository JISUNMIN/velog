✍️  개발하면서 API 응답이 느린 것 같은데 "정확히 얼마나 느린지",
timeout 때문에 실패한 건지, 헷갈렸던 적 없으신가요?
개발자도구(F12)에서 응답 시간과 timeout 상황을 보는 법을 정리해봅니다.

✅ 1. 응답 시간 확인하는 방법

크롬에서 F12 → **Network 탭**을 보면 아래처럼 각 요청별로 타이밍을 볼 수 있습니다.
요청 하나를 클릭하면 하단에 **Timing 탭**이 있습니다.

![](https://velog.velcdn.com/images/sunmins/post/c7a4e15b-ce39-488c-8b41-6dd420fc0784/image.png)

*35.30ms는 0.0353초입니다

⏱ 주요 항목 정리

| F12 표시 항목                       | 일반적인 용어 (영문)                             | 설명                                                 |
| ------------------------------- | ---------------------------------------- | -------------------------------------------------- |
| **리소스 예약 (Queued)**             | Stalled / Queued                         | 요청이 실제로 보내지기 전, 브라우저 내부에서 대기하는 시간 (리소스 제한, 우선순위 등) |
| **대기열 (Queueing)**              | Stalled / Queued                         | 리소스 예약과 유사, 요청이 네트워크에 나가기 전 대기 상태                  |
| **연결 시작 (Connecting)**          | Initial connection / SSL                 | TCP 연결 및 SSL 핸드셰이크 과정에 소요된 시간                      |
| **중단됨 (Blocked)**               | Stalled                                  | 네트워크 스택이나 브라우저가 요청을 잠시 중단한 시간                      |
| **요청/응답 (Request/Response)**    | Request sent / Waiting (TTFB) / Response | 요청 전송부터 서버 첫 바이트 응답까지 포함된 시간                       |
| **요청 전송됨 (Request Sent)**       | Request sent                             | 클라이언트가 서버에 요청을 모두 보낸 상태                            |
| **서버 응답을 기다리는 중 (Waiting)**     | Waiting (TTFB)                           | 서버가 응답 첫 바이트를 보내기까지의 시간 (TTFB)                     |
| **콘텐츠 다운로드 (Content Download)** | Content Download                         | 서버 응답 데이터를 실제로 다운로드하는 시간                           |

## 요약

- **Stalled / Queued / 대기열 / 리소스 예약**  
  요청이 실제 전송되기 전에 브라우저나 OS에서 대기하는 시간입니다. (리소스 제한, 우선순위 등)

- **Connecting / 연결 시작**  
  TCP 연결 및 SSL 핸드셰이크 시간입니다.

- **Request Sent / 요청 전송됨**  
  클라이언트가 서버에 요청을 모두 보낸 시점입니다.

- **Waiting / 서버 응답 기다림 (TTFB)**  
  서버가 응답을 준비하는 시간으로, 전체 지연 중 가장 중요한 부분입니다.

- **Content Download / 콘텐츠 다운로드**  
  서버가 보낸 응답을 받아서 처리하는 시간입니다.


> 💡 **총 소요 시간 = 이 모든 타이밍의 합**입니다.  
> 그중에서도 `Waiting (TTFB)` 시간이 길다면, **서버 쪽 처리 지연** 가능성이 높습니다.

---

### ❗ 2. Timeout 문제란?

요청을 보냈는데 아무 응답 없이 **지정된 시간 이상 지나면 브라우저나 코드에서 요청을 중단**하게 됩니다. 이게 바로 "timeout"입니다.

#### 프론트엔드에서 timeout 오류 예시

- `fetch`는 기본적으로 timeout 설정이 없습니다.  
  → 직접 `AbortController`로 설정해줘야 합니다.
  
- `axios`는 timeout을 설정하지 않으면 무한 대기합니다.

```ts
// axios 예시
axios.get('/api/data', { timeout: 5000 }) // 5초 넘으면 오류 발생
```
 ⛔ timeout 오류를 F12에서 보는 법


여기서 **timeout은, 예를 들어 서버에서 요청 타임아웃이 60초로 설정되어 있는데,  
프론트엔드(axios)에서 설정한 요청 타임아웃이 50초일 때 발생하는 현상을 의미합니다.**  
저도 실제로 이런 사례를 겪었는데, 근본적인 해결책은 **서버 응답시간 향상(예: DB 최적화)**이며,  
프론트엔드에서 할 수 있는 방법은 **axios에 설정한 타임아웃 시간을 늘려주는 것**이었습니다.

---

- Network 탭에 요청은 보이지만 Status가 `failed` 또는 아예 없고  
- Timing 정보가 거의 비어 있거나, 마지막 단계에서 멈춘 상태  
- 콘솔에 `timeout exceeded` 또는 유사한 메시지가 출력됨  

이 경우는 **프론트엔드에서 요청을 중단한 상황**으로,  
서버는 아직 응답 처리 중일 수 있지만 클라이언트가 먼저 연결을 끊은 상태입니다.


### 🔧 3. 대처 방법

| 문제            | 해결 방법                              |
| ------------- | ---------------------------------- |
| 서버 응답이 느림     | 백엔드에 TTFB 전달하여 개선 요청               |
| timeout 오류 발생 | 프론트엔드에서 `timeout` 설정, 사용자에게 안내 메시지 |
| 네트워크 이슈       | 재시도 로직(retry), 백오프 전략(exponential backoff) 적용        |


### 🧠 마치며
개발자도구의 Timing 탭은 단순한 로그가 아니라, 병목을 파악하는 실마리입니다.
특히 TTFB가 길다면 백엔드 성능 이슈일 가능성이 높고, timeout은 단순히 "느림"이 아니라 아예 요청 실패로 이어질 수 있기 때문에 주의 깊게 다뤄야 합니다.